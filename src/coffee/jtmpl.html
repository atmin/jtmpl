<!doctype html>
<html>
    <head>
        <link rel="stylesheet" href="/css/styles.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css">
        <script src="/js/jtmpl.js"></script>
        <title>jtmpl</title>
    </head>
    <body>
        <div class="wrapper">
          <h1><span>{<span>&rsaquo;</span></span> <a href="/">jtmpl</a> <sup>0.3</sup></h1>
          <h2 id="introduction">Introduction</h2>
<p>jtmpl is written in <a href="http://ashkenas.com/literate-coffeescript/">Literate CoffeeScript</a>.
Production version is generated by extracting the code, compiling and minifying it via UglifyJS.</p>
<p>This documentation is currently a draft.</p>
<h2 id="interface">Interface</h2>
<h4 id="compile-template">Compile template</h4>
<p><em>(NodeJS and browser)</em></p>
<p>jtmpl(String template, AnyType model)</p>
<p><code>jtmpl(&#39;Hello, {{who}}&#39;, { who: &#39;world&#39; }) # &quot;Hello, &lt;span data-jt=&quot;who&quot;&gt;&lt;/span&gt;&quot;</code>
`jtmpl(&#39;#template-id&#39;, { who: &#39;world&#39; })   # Browser only</p>
<h4 id="bind">Bind</h4>
<p>Bind model to DOM node using data-jt attributes</p>
<p><em>(browser only)</em></p>
<p>jtmpl(DOMElement target, Object model)</p>
<h4 id="compile-if-needed-and-bind">Compile (if needed) and bind</h4>
<p><em>(browser only)</em></p>
<p>jtmpl(DOMElement target, String template, AnyType model)</p>
<p><code>jtmpl(&#39;#target&#39;, &#39;Hello, {{who}}&#39;, model)</code></p>
<p><code>jtmpl(&#39;#target&#39;, &#39;#template-id&#39;, model)</code></p>
<p><code>jtmpl(&#39;#target&#39;, &#39;#target&#39;, model) # target.innerHTML will be used as template</code></p>
<h4 id="requests">Requests</h4>
<p><em>(currently browser only)</em></p>
<p>Only GET and POST currently supported.</p>
<p>jtmpl(String method, String url [, Object params] [, Function callback])</p>
<p><code>jtmpl(&#39;GET&#39;, &#39;api/endpoint/42&#39;) # fire and forget</code></p>
<p><code>jtmpl(&#39;GET&#39;, &#39;api/endpoint/42&#39;, function (response) { alert(response) })</code></p>
<p>If response is valid JSON, it&#39;s automatically parsed</p>
<p><code>jtmpl(&#39;POST&#39;, &#39;api/endpoint&#39;, { id: 42, answer: 42 }, function (err, resp) { ... })</code></p>
<p>Main function</p>
<p>Export for NodeJS and browser</p>
<p>A big <code>if..else if</code> statement as arguments pattern matcher</p>
<pre><code>jtmpl = (exports ? this).jtmpl = (target, template, model, options) -&gt;

  args = [].slice.call(arguments)

  # Deprecated. `jtmpl(selector)`?
  if args.length is 1 and typeof args[0] is &#39;string&#39;
    [].slice.call(document.querySelectorAll(args[0]))

  # `jtmpl(&#39;HTTP_METHOD&#39;, url[, parameters[, callback[, options]]])`?
  else if args[0] in [&#39;GET&#39;, &#39;POST&#39;]
    xhr = new XMLHttpRequest()
    callback = args.reduce(
      (prev, curr) -&gt; typeof curr is &#39;function&#39; and curr or prev,
      null
    )
    opts = args[args.length - 1]
    if typeof opts isnt &#39;object&#39; then opts = {}
    for prop in Object.getOwnPropertyNames(opts)
      xhr[prop] = opts[prop]
    request = if typeof args[2] is &#39;string&#39; then args[2] else if typeof args[2] is &#39;object&#39; then JSON.stringify(args[2]) else &#39;&#39;
    xhr.onload = (event) -&gt;
      if callback
        callback.call(this, this.responseText, event)
    xhr.open(args[0], args[1], opts.async or true, opts.user, opts.password)
    xhr.send(request)

  # `jtmpl(template, model[, options])`?
  else if typeof args[0] is &#39;string&#39; and typeof args[1] isnt &#39;string&#39; and args[1] isnt null and args.length in [2, 3]
    template = &#39;&#39; + (args[0].match(RE_NODE_ID) and document.querySelector(args[0]).innerHTML or args[0])
    opts = jtmpl.options(args[2], args[1])

    ## Preprocess template
    for rule in jtmpl.preprocessingRules
      template = template.replace(regexp(rule[0], opts.delimiters), rule[1])

    jtmpl.compile(template, args[1], null, false, opts).trim()

  # `jtmpl(target, model[, options])`?
  else if typeof args[0].cloneNode is &#39;function&#39; and typeof args[1] is &#39;object&#39;
    # Pre-binding stage
    jtmpl.prebind(args[1])

    # Bind recursively using data-jt attributes
    jtmpl.bind(args[0], args[1], jtmpl.options(args[2], args[1]))

  # `jtmpl(target, template, model[, options])`
  else
    target = typeof args[0].cloneNode is &#39;function&#39; and args[0] or document.querySelector(args[0])
    template = args[1].match(RE_NODE_ID) and document.querySelector(args[1]).innerHTML or args[1]
    model = args[2]
    opts = jtmpl.options(args[3], args[2])

    if target.nodeName is &#39;SCRIPT&#39;
      newTarget = document.createElement(opts.defaultTargetTag)
      newTarget.id = target.id
      target.parentNode.replaceChild(newTarget, target)
      target = newTarget

    html = jtmpl(template, model, opts)
    if target.innerHTML isnt html then target.innerHTML = html

    jtmpl(target, model, opts)</code></pre>
<p>Default options</p>
<pre><code>jtmpl.defaultOptions = {

  delimiters: &#39;{{ }}&#39;

  compiledDelimiters: &#39;#{ }#&#39;

  defaultSection: &#39;div&#39;

  defaultSectionItem: &#39;div&#39;

  defaultVar: &#39;span&#39;

  defaultTargetTag: &#39;div&#39;
}</code></pre>
<p>Construct options object by merging default and specified options    </p>
<pre><code>jtmpl.options = (options, rootModel) -&gt;
  options = options or {}
  opts = JSON.parse(JSON.stringify(jtmpl.defaultOptions))
  for prop of Object.getOwnPropertyNames(options)
    opts[prop] = options[prop]
  # if typeof options.delimiters is &#39;string&#39;
  opts.delimiters = opts.delimiters.split(&#39; &#39;)
  # if typeof options.compiledDelimiters is &#39;string&#39;
  opts.compiledDelimiters = opts.compiledDelimiters.split(&#39; &#39;)
  opts.rootModel = if options.rootModel then options.rootModel else rootModel
  opts</code></pre>
<h2 id="rules">Rules</h2>
<p>jtmpl is a processor of rules. </p>
<p>Rules in sequences are in increasing generality order. It&#39;s just like 
<a href="http://learnyouahaskell.com/syntax-in-functions">Haskell pattern matching</a>.</p>
<p>Compilation and binding stages can be extended with new rules,
put them at the beginning:</p>
<p><code>jtmpl.compileRules.unshift({ new compile rule... })</code><br><code>jtmpl.bindRules.unshift({ new binding rule... })</code></p>
<h3 id="regular-expression-atoms">Regular expression atoms</h3>
<p>Used in various matchers</p>
<pre><code>RE_IDENTIFIER = &#39;[\\w\\.\\-]+&#39;
RE_NODE_ID = &#39;^#[\\w\\.\\-]+$&#39;
RE_ANYTHING = &#39;[\\s\\S]*?&#39;
RE_SPACE = &#39;\\s*&#39;
RE_PIPE = &quot;(?: \\| (#{ RE_IDENTIFIER }) )?&quot;
RE_DATA_JT = &#39;(?: ( \\s* data-jt = &quot; [^&quot;]* )&quot; )?&#39;
RE_COLLECTION_TEMPLATE = /^(#|\^)\s([\s\S]*)$/</code></pre>
<h3 id="pre-processing-rules">Pre-processing rules</h3>
<p>Transformations to clean up template for easier matching</p>
<pre><code>jtmpl.preprocessingRules = [
  # Convert triple mustache (output unescaped var) to alt form
  [&quot;({{) { (#{ RE_IDENTIFIER }) } (}})&quot;, &#39;$1&amp;$2$3&#39;]

  # Strip HTML comments that enclose tokens
  [&quot;&lt;!-- #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } --&gt;&quot;, &#39;$1&#39;]

  # Strip single quotes around html element attributes associated with tokens
  [&quot;(#{ RE_IDENTIFIER })=&#39;({{ #{ RE_IDENTIFIER } }})&#39;&quot;, &#39;$1=$2&#39;]

  # Strip double quotes around html element attributes associated with tags
  [&quot;(#{ RE_IDENTIFIER })=\&quot;({{ #{ RE_IDENTIFIER } }})\&quot;&quot;, &#39;$1=$2&#39;]

  # If tags stand on their own line remove the line, keep the tag only
  [&quot;\\n #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } \\n&quot;, &#39;\n$1\n&#39;]
]</code></pre>
<h3 id="formatters-and-mappings">Formatters and mappings</h3>
<p>None provided by default, put yours like <code>jtmpl.formatters.myFormatter = function (val) {...}</code></p>
<pre><code>jtmpl.formatters = {}    
jtmpl.mappings = {}    </code></pre>
<h3 id="compile-rules">Compile rules</h3>
<p>Delimiters in <code>pattern</code>s are replaced with escaped options.delimiters, whitespace - stripped.</p>
<p>Inline tags implement <code>replaceWith</code>, section (block) tags implement <code>contents</code>.</p>
<p>Signatures:</p>
<p>[String, Array] <code>replaceWith</code> (String for each group in pattern, AnyType model)</p>
<p>String <code>bindingToken</code> (String for each group in pattern)</p>
<p>[String, Array] <code>contents</code> (String template, AnyType model, String section, Object options)</p>
<pre><code>jtmpl.compileRules = [</code></pre>
<h4 id="-tag-class-class-name-other-classes-"><code>&lt;tag class=&quot;{{class-name}} other-classes&quot;&gt;</code></h4>
<p><code>model[&#39;class-name&#39;]</code> is expected to be boolean</p>
<pre><code>  {
    pattern: &quot;(class=\&quot;? [\\w \\. \\- \\s {{}}]*) {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (pre, prop, model) -&gt;
      val = getValue(model, prop)
      [ # Emit match, and class name if booleanVar
        (pre.search(&#39;{&#39;) is -1 and pre or &#39; &#39;) +
        (typeof val is &#39;boolean&#39; and val and prop or &#39;&#39;)
        ,
        []
      ]

    echoReplaceWith: (pre, prop) -&gt;
      if pre.search(&#39;{&#39;) &gt; - 1 then &quot; {{#{ prop }}}&quot; else null

    bindingToken: (pre, prop) -&gt; &quot;class=#{ prop }&quot;
  }</code></pre>
<h4 id="-tag-onevent-handler-"><code>&lt;tag onevent=&quot;{{handler}}&quot;&gt;</code></h4>
<p><code>on</code>-prefixed properties are event handlers.
<code>handler</code> is expected to be a function,
<code>handler</code>&#39;s <code>this</code> is the context in which the handler has been attached.
No need to add <code>onchange</code> handlers, syncing of DOM element values and <code>model</code> is already handled.</p>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: -&gt; [&#39;&#39;, []]

    bindingToken: (event, handler) -&gt; &quot;on#{ event }=#{ handler }&quot;
  }</code></pre>
<h4 id="-tag-attr-prop-"><code>&lt;tag attr=&quot;{{prop}}&quot;</code></h4>
<p>When <code>prop</code> is null property is absent, otherwise equals <code>prop</code>.</p>
<p>When <code>prop</code> is boolean, value determines presense of attribute.</p>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (attr, prop, model) -&gt;
      val = getValue(model, prop)
      # null?
      if not val? or val is null
        [&#39;&#39;, []]
      # boolean?
      else if typeof val is &#39;boolean&#39;
        [(if val then attr else &#39;&#39;), []]
      # quoted value
      else
        [&quot;#{ attr }=\&quot;#{ val }\&quot;&quot;, []]

    bindingToken: (attr, prop) -&gt; &quot;#{ attr }=#{ prop }&quot;
  }</code></pre>
<h4 id="-inverted_section-"><code>{{^inverted_section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\^ (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultSection&#39;

    lastTag: (model, section) -&gt;
      if Array.isArray(model[section]) then section else null

    contents: (template, model, section, options) -&gt;
      val = getValue(model, section)

      # Sequence?
      if Array.isArray(val)
        [
          # Render body if array empty
          if not val.length then jtmpl(template, model) else &#39;&#39;
          ,
          [
            [ # template as node data attribute
              &#39;data-jt-0&#39;,

              multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
            ]
          ]
        ]

      else
        [ jtmpl(template, model),
          if val then [[&#39;style&#39;, &#39;display:none&#39;]] else []
        ]

    bindingToken: (section) -&gt; &quot;^#{ section }&quot;
  }</code></pre>
<h4 id="-section-"><code>{{#section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\# (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$&quot;

    lastTag: (model, section) -&gt;
      if Array.isArray(model[section]) then section else null

    wrapper: &#39;defaultSection&#39;

    contents: (template, model, section, mapping, options) -&gt;
      val = getValue(model, section)
      # Sequence?
      if Array.isArray(val)
        mapping = options.rootModel[mapping] or model[mapping] or jtmpl.mappings[mapping]
        if typeof mapping is &#39;function&#39;
          val = val.map(mapping).filter((x) -&gt; x isnt null and x isnt undefined)

        [ # Render body for each item
          (jtmpl(template, item, { asArrayItem: true }) for item in val).join(&#39;&#39;),
          [ # template as node data attribute
            [
              &#39;data-jt-1&#39;,

              multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
            ]
          ]
        ]

      # Context?
      else if typeof val is &#39;object&#39;
        # Render body using context
        [ jtmpl(template, val),
          []
        ]

      else
        [ jtmpl(template, model),
          if not val then [[&#39;style&#39;, &#39;display:none&#39;]] else []
        ]

    bindingToken: (section) -&gt; &quot;##{ section }&quot;
  }</code></pre>
<h4 id="-unescaped_var-"><code>{{&amp;unescaped_var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ &amp; (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, model) -&gt; [getValue(model, prop), []]

    bindingToken: (prop) -&gt; prop
  }</code></pre>
<h4 id="-var-"><code>{{var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, formatter, model) -&gt; [escapeHTML(getValue(model, prop, undefined, undefined, model[formatter] || jtmpl.formatters?[formatter] || null)), []]

    bindingToken: (prop, formatter) -&gt; prop + (if formatter then &#39;|&#39; + formatter else &#39;&#39;)
  }

]</code></pre>
<h3 id="bind-rules">Bind rules</h3>
<p>Matching is done on tokenized data-jt items</p>
<p><code>react</code> signature:</p>
<p>Function void (AnyType val) <code>react</code>
(DOMElement node, String for each pattern group, AnyType model, Object options)</p>
<pre><code>jtmpl.bindRules = [</code></pre>
<h4 id="-value-checked-selected-var-"><code>value/checked/selected=var</code></h4>
<pre><code>  {
    pattern: &quot;(value | checked | selected) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop,

    react: (node, attr, prop, model) -&gt;
      # attach DOM reactor

      # select option?
      if node.nodeName is &#39;OPTION&#39;
        node.parentNode.addEventListener(&#39;change&#39;, -&gt;
          if model[prop] isnt node.selected then model[prop] = node.selected
        )

      # radio group?
      if node.type is &#39;radio&#39; and node.name
        node.addEventListener(&#39;change&#39;, -&gt;
          if node[attr]
            for input in document.querySelectorAll(&quot;input[type=radio][name=#{ node.name }]&quot;)
              if input isnt node
                input.dispatchEvent(new Event(&#39;change&#39;))
          model[prop] = node[attr]
        )

      # text input?
      if node.type is &#39;text&#39;
        node.addEventListener(&#39;input&#39;, -&gt; model[prop] = node[attr])

      # other inputs
      else
        node.addEventListener(&#39;change&#39;, -&gt; model[prop] = node[attr])

      reaction = (val) -&gt;
        val = getValue(model, prop, true, reactor)
        if val is undefined then return

        if node[attr] isnt val then node[attr] = val

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }</code></pre>
<h4 id="onevent-var">onevent=var</h4>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    react: (node, evnt, listener, model, options) -&gt;
      handler = options?.rootModel?[listener] or model[listener]
      if typeof handler is &#39;function&#39;
        node.addEventListener(evnt, handler.bind(model))
      else
        throw &quot;:( #{ listener } is not a function, cannot attach event handler&quot;

      # job done, no reactor to return
      null
  }</code></pre>
<h4 id="class-var">class=var</h4>
<pre><code>  {
    pattern: &quot;class = (#{ RE_IDENTIFIER })&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, model) -&gt;
      reaction = (val) -&gt;
        (val and addClass or removeClass)(node, prop)

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }</code></pre>
<h4 id="attr-var">attr=var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop

    react: (node, attr, prop, model) -&gt;
      reaction = (val) -&gt;
        if node[attr] isnt val then node[attr] = val

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }</code></pre>
<h4 id="section">section</h4>
<pre><code>  {
    pattern: &quot;(# | \\^) (#{ RE_IDENTIFIER })&quot;

    bindTo: (sectionType, prop) -&gt; prop

    # context for recursion
    recurseContext: (sectionType, attr, model) -&gt;
      val = model[attr]
      if Array.isArray(val)
        null
      else if typeof val is &#39;object&#39;
        val
      else
        model

    react: (node, sectionType, attr, model, options) -&gt;
      val = model[attr]

      if Array.isArray(val) and sectionType is &#39;#&#39;
        jtmpl.bindArrayToNodeChildren(val, node, options)
        # bind collection items to node children
        for child, i in node.children
          if typeof val[i] is &#39;object&#39;
            jtmpl.bind(child, val[i], options)

      reaction = (val) -&gt;
        # collection?
        if Array.isArray(val)
          jtmpl.bindArrayToNodeChildren(val, node, options)

          node.innerHTML =
            if not val.length
              jtmpl(
                multiReplace(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;,
                  options.compiledDelimiters, options.delimiters),
                {}
              )
            else 
              &#39;&#39;

          node.appendChild(jtmpl.createSectionItem(node, item, options)) for item in val

        # local context?
        else if typeof val is &#39;object&#39;
          node.innerHTML = jtmpl(
            multiReplace(node.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;,
                options.compiledDelimiters, options.delimiters),
            val
          )
          jtmpl(node, node.innerHTML, val, { rootModel: model })

        # if section
        else
          node.style.display = (!val isnt (sectionType is &#39;^&#39;)) and &#39;none&#39; or &#39;&#39;

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[attr] is &#39;function&#39; then reactor(getValue(model, attr, true, reaction))

      reactor
  }</code></pre>
<h4 id="var">var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) #{ RE_PIPE }&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, formatter, model, options) -&gt;
      reaction = (val) -&gt;
        node.innerHTML = (options.rootModel?[formatter] or model[formatter] or jtmpl.formatters?[formatter] or ((x) -&gt; x))(val)
        if typeof val is &#39;object&#39; then jtmpl.bind(node, model, options)

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction, formatter))

      reactor
  }



]</code></pre>
<h2 id="compile-rules-processor">Compile rules processor</h2>
<h3 id="compile-routine">Compile routine</h3>
<p>Tokenize template and apply each rule on tokens.
Rules can be inline or recursive, end block is hardcoded as &quot;{{/block}}&quot;.
Current delimiters are respected.</p>
<p>String  template
AnyType model
String  openTag
Boolean echoMode
Array   delimiters
Boolean asArrayItem</p>
<pre><code>jtmpl.compile = (template, model, openTag, echoMode, options, asArrayItem) -&gt;

  tokenizer = regexp(&quot;{{ (\/?) (#{ RE_ANYTHING }) }}&quot;, options.delimiters)
  result = &#39;&#39;
  pos = 0

  while (token = tokenizer.exec(template))

    # End block?
    if token[1]
      if token[2] isnt openTag
        throw new Error(openTag and
          &quot;:( expected {{/#{ openTag }}}, got {{#{ token[2] }}}&quot; or
          &quot;:( unexpected {{/#{ token[2] }}}&quot;)

      # Exit recursion
      return result + template.slice(pos, tokenizer.lastIndex - token[0].length)

    slice = template.slice(Math.max(0, pos - 128), tokenizer.lastIndex)

    # Process rules
    for rule in jtmpl.compileRules

      match = regexp(rule.pattern, options.delimiters).exec(slice)
      if match
        # accumulate output
        result += template.slice(pos, tokenizer.lastIndex - match[0].length)

        # inject token in data-jt attr
        htagPos = lastOpenedHTMLTag(result)
        bindingToken = rule.bindingToken(match.slice(1)...)

        # inline tag or section?
        if rule.replaceWith?
          if echoMode
            result += rule.echoReplaceWith?(match.slice(1)...) or match[0]
          else
            [replaceWith, wrapperAttrs] =
              rule.replaceWith(match.slice(1).concat([model])...)

            if htagPos is -1 and rule.wrapper?
              # wrapping needed
              tag = options[rule.wrapper]
              result += injectAttributes(
                injectTagBinding(&quot;&lt;#{ tag }&gt;#{ replaceWith }&lt;/#{ tag }&gt;&quot;, bindingToken),
                wrapperAttrs
              )
            else
              result += replaceWith
              result = result.slice(0, htagPos) + injectAttributes(
                injectTagBinding(result.slice(htagPos), bindingToken),
                wrapperAttrs
              )

          pos = tokenizer.lastIndex

        else
          # Recursively get nested template (echoMode=on)
          tmpl = jtmpl.compile(
            template.slice(tokenizer.lastIndex), 
            model, match[1], true, options)

          # Skip block contents
          tokenizer.lastIndex += tmpl.length

          # Match close block token
          closing = tokenizer.exec(template)
          pos = tokenizer.lastIndex

          if echoMode
            result += token[0] + tmpl + closing[0]
          else
            section = match[1]
            args = [tmpl, model].concat(match.slice(1)).concat([options])
            [contents, wrapperAttrs] = rule.contents(args...)

            if htagPos is -1
              tag = options[rule.wrapper]

              if section isnt lastSectionTag
                lastSectionHTagPos = result.length
                result += injectAttributes(
                  injectTagBinding(&quot;&lt;#{ tag }&gt;#{ contents }&lt;/#{ tag }&gt;&quot;, bindingToken),
                  wrapperAttrs
                )
              else
                result = (
                  result.slice(0, lastSectionHTagPos) +
                  injectAttributes(
                    injectTagBinding(result.slice(lastSectionHTagPos), bindingToken),
                    wrapperAttrs,
                    contents.trim()
                  )
                )

            else
              result = (
                result.slice(0, htagPos) + 
                injectAttributes(
                  injectTagBinding(result.slice(htagPos), bindingToken),
                  wrapperAttrs
                ) +
                contents.trim()
              )
              lastSectionHTagPos = htagPos

            lastSectionTag = rule.lastTag?(model, section) or null


        # Match was found, skip other rules
        break

  result += template.slice(pos)

  # Return accumulated output
  if options.asArrayItem

    # enclose in defaultSectionItem HTML tag if needed
    if isValidHTMLTag(result)
      result 
    else
      tag = options.defaultSectionItem
      &quot;&lt;#{ tag }&gt;#{ result }&lt;/#{ tag }&gt;&quot;

  else
    result</code></pre>
<h3 id="compiling-stage-supporting-utilities">Compiling stage supporting utilities</h3>
<p>String addTagBinding(String, String)</p>
<p>Inject token in HTML element data-jt attribute.
Create attribute if not existent.
wrapperAttrs is array of pairs [attribute, value] to inject in element</p>
<pre><code>injectTagBinding = (template, token) -&gt;
  # group 1: &#39;data-jt&#39; inject position
  # group 2: token inject position, if attribute exists
  # group 3 (RE_DATA_JT): existing &#39;data-jt&#39; value
  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER }) (#{ RE_ANYTHING }) #{ RE_DATA_JT }&quot;).exec(template)
  attrLen = (match[3] or &#39;&#39;).length
  pos = match[1].length + match[2].length + attrLen
  # inject, return result
  ( template.slice(0, pos) +
    ( if attrLen
        (if match[3].trim() is &#39;data-jt=&quot;&#39; then &#39;&#39; else &#39; &#39;) + token
      else
        &#39; data-jt=&quot;&#39; + token + &#39;&quot;&#39;
    ) +
    template.slice(pos)
  )

injectAttributes = (template, attributes, contents) -&gt;
  if not attributes.length then return template

  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER } #{ RE_ANYTHING })&gt;&quot;).exec(template)
  pos = match[1].length
  (
    template.slice(0, pos) + 
    [&quot; #{ pair[0] }=\&quot;#{ pair[1].replace(/&quot;/g, &#39;&amp;quot;&#39;).replace(/&gt;/g, &#39;&amp;gt;&#39;).replace(/&lt;/g, &#39;&amp;lt;&#39;) }\&quot;&quot; for pair in attributes].join(&#39;&#39;) +
    &#39;&gt;&#39; +
    (contents or &#39;&#39;) +
    template.slice(pos + 1)
  )</code></pre>
<p>Int lastOpenedHTMLTag(String)</p>
<p>Return index of the last opening, maybe opened (no close bracket), HTML tag
followed by end of string, or -1, if no such exists</p>
<pre><code>lastOpenedHTMLTag = (template) -&gt;
  template.trimRight().search(regexp(&quot;&lt; #{ RE_IDENTIFIER } [^&gt;]*? &gt;?$&quot;))</code></pre>
<p>Boolean isValidHTMLTag(String)</p>
<p>Check if contents is properly formatted closed HTML tag</p>
<pre><code>isValidHTMLTag = (contents) -&gt;
  !!contents.trim().match(regexp(&quot;^&lt;(#{ RE_IDENTIFIER }) #{ RE_SPACE }
    [^&gt;]*? &gt; #{ RE_ANYTHING } &lt;/\\1&gt;$ | &lt; [^&gt;]*? /&gt;$&quot;)
  )</code></pre>
<h2 id="pre-binding-stage">Pre-binding stage</h2>
<p>Init function (<code>model[&#39;#&#39;]</code>) and routes via window onhashchange are processed here.</p>
<p>If route definition contains a &#39;(&#39;, then it&#39;s considered regular expression
and groups are passed as parameters to the route handler.</p>
<p>Example routes:</p>
<p><code>&#39;#simple-route&#39;: function () { ...</code></p>
<p><code>&#39;#page-(\\d+)&#39;: function (pageNumber) { ...</code></p>
<pre><code>jtmpl.prebind = (model) -&gt;
  if typeof model[&#39;#&#39;] is &#39;function&#39;
    model[&#39;#&#39;].apply(model)

  props = Object.getOwnPropertyNames(model)
  routes = props.filter((prop) -&gt; regexp(&quot;##{ RE_ANYTHING }&quot;).exec(prop))

  if routes.length and window
    hashchange = -&gt; 
      for route in routes
        if &#39;(&#39; in route
          match = new RegExp(route, &#39;g&#39;).exec(window.location.hash)
          if match and typeof model[route] is &#39;function&#39;
            model[route].apply(model, match.slice(1))
        else
          if route is window.location.hash and typeof model[route] is &#39;function&#39;
            model[route].apply(model)

    hashchange()

    window.addEventListener(&#39;hashchange&#39;, hashchange)</code></pre>
<h2 id="bind-rules-processor">Bind rules processor</h2>
<p>void <code>bind</code> (DOMElement root, AnyType model)</p>
<p>Walk DOM and setup reactors on model and nodes.</p>
<pre><code>jtmpl.bind = (node, model, options) -&gt;

  if data_jt = node.getAttribute(&#39;data-jt&#39;)

    for jt in data_jt.trim().split(&#39; &#39;)

      for rule in jtmpl.bindRules

        if match = regexp(rule.pattern).exec(jt)

          reactor = rule.react([node].concat(match.slice(1), [model, options])...)
          prop = rule.bindTo?(match.slice(1)...)
          if model[prop] is undefined then model[prop] = null
          propChange(model, prop, reactor)

          recurseContext = rule.recurseContext?(match.slice(1).concat([model])...)

          break

  if recurseContext isnt null
    for child in node.children
      jtmpl.bind(child, recurseContext or model, options)</code></pre>
<h2 id="supporting-code">Supporting code</h2>
<h3 id="regular-expression-utilities">Regular expression utilities</h3>
<p>String escapeRE(String s)</p>
<p>Escape regular expression characters</p>
<pre><code>escapeRE = (s) -&gt; (s + &#39;&#39;).replace(/([.?*+^$[\]\\(){}|-])/g, &#39;\\$1&#39;)</code></pre>
<p>RegExp regexp(String src, Object options)</p>
<p>Replace mustaches with given delimiters, strip whitespace, return RegExp</p>
<pre><code>regexp = (src, delimiters) -&gt;
  # strip whitespace
  src = src.replace(/\s+/g, &#39;&#39;)
  new RegExp((if delimiters then src
    .replace(&#39;{{&#39;,  escapeRE(delimiters[0]))
    .replace(&#39;}}&#39;,  escapeRE(delimiters[1]))
    else src)
  , &#39;g&#39;)</code></pre>
<p>AnyType getValue(AnyType model, String prop[, Function callback[, Function self]])</p>
<p>Get value of <code>model[prop]</code>, evaluate value function if computed value</p>
<p>When <code>model[prop]</code> is function, it should use <code>this</code> to refer to model properties,
like <code>this(&#39;foo&#39;)</code> or even <code>@ &#39;foo&#39;</code> in CoffeeScript. </p>
<p>When in <code>trackDependencies</code> mode:</p>
<p>value function can compute the result asynchronously,
return undefined to signal this, finally call <code>callback</code> with computed value on success.</p>
<p><code>model.__dependents[prop]</code> registers all descendents for a <code>prop</code></p>
<pre><code>getValue = (model, prop, trackDependencies, callback, formatter) -&gt;
  formatter = formatter or (x) -&gt; x

  getter = (prop) -&gt;
    result = model[prop]
    formatter(
      if typeof result is &#39;function&#39;
        result.call(getter)
      else
        result
    )

  dependencyTracker = (propToReturn) -&gt;
    model.__dependents[propToReturn] ?= []
    if model.__dependents[propToReturn].indexOf(prop) is -1
      model.__dependents[propToReturn].push(prop)
    getter(propToReturn)

  if prop is &#39;.&#39; then return formatter(model)

  val = model[prop]
  if typeof val is &#39;function&#39;
    val.call(
      # `this` function
      if trackDependencies 
        model.__dependents ?= {}
        dependencyTracker
      else
        getter
      ,
      callback
    )
  else
    formatter(val)</code></pre>
<h3 id="string-utilities">String utilities</h3>
<p>String escapeHTML(String val)</p>
<p>Replace HTML special characters</p>
<pre><code>escapeHTML = (val) -&gt;
  (val? and val or &#39;&#39;)
    .toString()
    .replace /[&amp;&quot;&lt;&gt;\\]/g, (s) -&gt; { 
        &#39;&amp;&#39;: &#39;&amp;amp;&#39;
        &#39;\\&#39;: &#39;\\\\&#39;
        &#39;&quot;&#39;: &#39;\&quot;&#39;
        &#39;&lt;&#39;: &#39;&amp;lt;&#39;
        &#39;&gt;&#39;: &#39;&amp;gt;&#39;
      }[s]</code></pre>
<p>String multiReplace(String template, Array from, Array to)</p>
<p>Replace <code>from</code> literal strings with <code>to</code> strings in template</p>
<pre><code>multiReplace = (template, from, to) -&gt;
  for find, i in from
    template = template.replace(regexp(escapeRE(find)), to[i])
  template</code></pre>
<h3 id="dom-utilities">DOM utilities</h3>
<p>DOMElement createSectionItem (DOMElement parent, AnyType context)</p>
<pre><code>jtmpl.createSectionItem = createSectionItem = (parent, context, options) -&gt;
  if context is undefined then context = {}
  element = document.createElement(&#39;body&#39;)
  element.innerHTML = jtmpl(
    multiReplace(parent.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;,
      options.compiledDelimiters, options.delimiters),
    context
  )
  element = element.children[0]
  if typeof context is &#39;object&#39;
    jtmpl(element, element.innerHTML, context, options)
  element

jtmpl.hasClass = hasClass = (el, name) -&gt; new RegExp(&quot;(\\s|^)#{ name }(\\s|$)&quot;).test(el.className)

jtmpl.addClass = addClass = (el, name) -&gt; 
  if not hasClass(el, name) then el.className += (el.className and &#39; &#39; or &#39;&#39;) + name

jtmpl.removeClass = removeClass = (el, name) -&gt;
  if hasClass(el, name) then el.className = el.className
    .replace(new RegExp(&quot;(\\s|^)#{name}(\\s|$)&quot;), &#39;&#39;)
    .replace(/^\s+|\s+$/g, &#39;&#39;)</code></pre>
<h3 id="binding-utilities">Binding utilities</h3>
<p>void propChange(Object obj, String prop, Function callback)</p>
<p>Register a callback to handle object property change. </p>
<pre><code>propChange = (obj, prop, callback) -&gt;
  # All must be specified, don&#39;t fail if not
  if not (obj and prop and callback) then return

  oldDescriptor = (Object.getOwnPropertyDescriptor(obj, prop) or
    Object.getOwnPropertyDescriptor(obj.constructor.prototype, prop))

  Object.defineProperty(obj, prop, {
    get: oldDescriptor.get or -&gt; oldDescriptor.value,
    set: ((val) -&gt;
      if signal = val?.__signal
        val = getValue(signal.obj, signal.prop, true, callback)
        if val isnt undefined then callback(val)
      else
        oldDescriptor.set?(val) or (
          if typeof oldDescriptor.value is &#39;function&#39;
            oldDescriptor.value.call(((p, val) -&gt; obj[p] = val), val)
          else
            oldDescriptor.value = val
        )
        callback(val)

      for dependent in obj.__dependents?[prop] or []
        obj[dependent] = {
          __signal: {
            obj: obj,
            prop: dependent
          }
        }

      return
    ),
    configurable: true
  })</code></pre>
<p>void bindArrayToNodeChildren(Array array, DOMElement node)</p>
<p>Bind an array to DOM node, 
so when array is modified, node children are updated accordingly.</p>
<p>Array is augmented by attaching listeners on existing indices
and setting a proxy for each mutable operation. 
<code>createSectionItem</code> is used for creating new items.</p>
<pre><code>jtmpl.bindArrayToNodeChildren = bindArrayToNodeChildren = (array, node, options) -&gt;

  # array already augmented?
  if not array.__garbageCollectNodes

    # it&#39;s possible for a referenced node to be destroyed. free the reference
    array.__garbageCollectNodes = -&gt;
      i = this.__nodes.length
      while --i
        if not this.__nodes[i].parentNode
          this.__nodes.splice(i, 1)

    array.__removeEmpty = -&gt;
      if not this.length then node.innerHTML = &#39;&#39;

    array.__addEmpty = -&gt;
      if not this.length
        node.innerHTML = jtmpl(
          multiReplace(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;,
            options.compiledDelimiters, options.delimiters),
          {}
        )

    # Mutable array operations

    array.pop = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      node.removeChild(node.children[node.children.length - 1]) for node in this.__nodes
      [].pop.apply(this, arguments)
      [].pop.apply(this.__values, arguments)
      this.__addEmpty()

    array.push = (item) -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
      [].push.apply(this, arguments)
      len = this.__values.length
      result = [].push.apply(this.__values, arguments)
      bindProp(item, len)
      result

    array.reverse = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      result = [].reverse.apply(this.__values, arguments)
      for node in this.__nodes
        node.innerHTML = &#39;&#39;
        for item, i in this.__values
          node.appendChild(createSectionItem(node, item, options))
          bindProp(item, i)
      this.__addEmpty()
      result

    array.shift = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      [].shift.apply(this, arguments)
      result = [].shift.apply(this.__values, arguments)
      for node in this.__nodes
        node.removeChild(node.children[0])
      for item, i in this.__values
        bindProp(item, i)
      this.__addEmpty()
      result

    array.unshift = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      for item in [].slice.call(arguments).reverse()
        for node in this.__nodes
          node.insertBefore(createSectionItem(node, item, options), node.children[0])
      [].unshift.apply(this, arguments)
      result = [].unshift.apply(this.__values, arguments)
      for item, i in this.__values
        bindProp(item, i)
      this.__addEmpty()
      result

    array.sort = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      [].sort.apply(this, arguments)
      result = [].sort.apply(this.__values, arguments)
      for node in this.__nodes
        node.innerHTML = &#39;&#39;
        for item, i in array
          node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
          bindProp(item, i)
      this.__addEmpty()
      result

    array.splice = (index, howMany) -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      for node in this.__nodes
        for i in [0...howMany]
          node.removeChild(node.children[index])
        for item in [].slice.call(arguments, 2)
          node.insertBefore(createSectionItem(node, item, options), node.children[index])
          bindProp(item, index)
      [].splice.apply(this, arguments)
      [].splice.apply(this.__values, arguments)
      this.__addEmpty()

    # Bind property
    bindProp = (item, i) -&gt;
      array.__values[i] = item
      Object.defineProperty(array, i, 
        get: -&gt; this.__values[i]
        set: (val) -&gt; 
          this.__garbageCollectNodes()
          this.__values[i] = val
          node.replaceChild(createSectionItem(node, val, options), node.children[i]) for node in this.__nodes
      )

    # bound nodes
    Object.defineProperty(array, &#39;__nodes&#39;,
      enumerable: false
      writable: true
      value: []
    )
    # onchange handlers for each item
    Object.defineProperty(array, &#39;__values&#39;,
      enumerable: false
      writable: true
      value: []
    )
    for item, i in array
      bindProp(item, i)

  if array.__nodes.indexOf(node) is -1 then array.__nodes.push(node)
  array</code></pre>

          <footer>
              <span>{&rsaquo;</span> Copyright &copy; 2013-2014 Atanas Minev, <a href="LICENSE">MIT license</a>
          </footer>
        </div>
        <script src="/js/highlight.min.js"></script>
        <script src="/js/highlight-coffee.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-43285803-1', 'jtmpl.com');
          ga('send', 'pageview');
        </script>
    </body>
</html>