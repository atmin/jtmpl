<!doctype html>
<html>
    <head>
        <link rel="stylesheet" href="/css/styles.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css">
        <script src="/js/jtmpl.js"></script>
        <title>jtmpl</title>
    </head>
    <body>
        <div class="wrapper">
          <h1><span>{<span>&rsaquo;</span></span> <a href="/">jtmpl</a> <sup>0.3.1</sup></h1>
          <h2 id="introduction">Introduction</h2>
<p>jtmpl is written in <a href="http://ashkenas.com/literate-coffeescript/">Literate CoffeeScript</a>.
Production version is generated by extracting the code, compiling and minifying it via UglifyJS.</p>
<p>This documentation is currently a draft.</p>
<h2 id="interface">Interface</h2>
<h4 id="compile-template">Compile template</h4>
<p><em>(NodeJS and browser)</em></p>
<p>jtmpl(String template, AnyType model)</p>
<p><code>jtmpl(&#39;Hello, {{who}}&#39;, { who: &#39;world&#39; }) # &quot;Hello, &lt;span data-jt=&quot;who&quot;&gt;&lt;/span&gt;&quot;</code>
`jtmpl(&#39;#template-id&#39;, { who: &#39;world&#39; })   # Browser only</p>
<h4 id="bind">Bind</h4>
<p>Bind model to DOM node using data-jt attributes</p>
<p><em>(browser only)</em></p>
<p>jtmpl(DOMElement target, Object model)</p>
<h4 id="compile-if-needed-and-bind">Compile (if needed) and bind</h4>
<p><em>(browser only)</em></p>
<p>jtmpl(DOMElement target, String template, AnyType model)</p>
<p><code>jtmpl(&#39;#target&#39;, &#39;Hello, {{who}}&#39;, model)</code></p>
<p><code>jtmpl(&#39;#target&#39;, &#39;#template-id&#39;, model)</code></p>
<p><code>jtmpl(&#39;#target&#39;, &#39;#target&#39;, model) # target.innerHTML will be used as template</code></p>
<h4 id="requests">Requests</h4>
<p><em>(currently browser only)</em></p>
<p>Only GET and POST currently supported.</p>
<p>jtmpl(String method, String url [, Object params] [, Function callback])</p>
<p><code>jtmpl(&#39;GET&#39;, &#39;api/endpoint/42&#39;) # fire and forget</code></p>
<p><code>jtmpl(&#39;GET&#39;, &#39;api/endpoint/42&#39;, function (response) { alert(response) })</code></p>
<p>If response is valid JSON, it&#39;s automatically parsed</p>
<p><code>jtmpl(&#39;POST&#39;, &#39;api/endpoint&#39;, { id: 42, answer: 42 }, function (resp) { ... })</code></p>
<p>Main function</p>
<p>Export for NodeJS and browser</p>
<p>A big <code>if..else if</code> statement as arguments pattern matcher</p>
<pre><code>jtmpl = (exports ? this).jtmpl = (target, template, model, options) -&gt;

  args = [].slice.call(arguments)

  # Deprecated. `jtmpl(selector)`?
  if args.length is 1 and typeof args[0] is &#39;string&#39;
    [].slice.call(document.querySelectorAll(args[0]))

  # `jtmpl(&#39;HTTP_METHOD&#39;, url[, parameters[, callback[, options]]])`?
  else if args[0] in [&#39;GET&#39;, &#39;POST&#39;]
    jtmpl.xhr(args)

  # `jtmpl(template, model[, options])`?
  else if typeof args[0] is &#39;string&#39; and (typeof args[1] isnt &#39;string&#39; or args.length is 2) and args.length in [2, 3]
    template = &#39;&#39; + (args[0].match(RE_NODE_ID) and document.querySelector(args[0]).innerHTML or args[0])
    opts = jtmpl.options(args[2], args[1])

    ## Preprocess template
    for rule in jtmpl.preprocessingRules
      template = template.replace(regexp(rule[0], opts.delimiters), rule[1])

    jtmpl.compile(template, args[1], null, false, opts).trim()

  # `jtmpl(target, model[, options])`?
  else if typeof args[0].cloneNode is &#39;function&#39; and typeof args[1] is &#39;object&#39;
    # Bind recursively using data-jt attributes
    jtmpl.bind(args[0], args[1], jtmpl.options(args[2], args[1]))

    # Post-binding stage
    jtmpl.postbind(args[1])

  # `jtmpl(target, template, model[, options])`
  else
    target = typeof args[0].cloneNode is &#39;function&#39; and args[0] or document.querySelector(args[0])
    template = args[1].match(RE_NODE_ID) and document.querySelector(args[1]).innerHTML or args[1]
    model = args[2]
    opts = jtmpl.options(args[3], args[2])

    if target.nodeName is &#39;SCRIPT&#39;
      newTarget = document.createElement(opts.defaultTargetTag)
      newTarget.id = target.id
      target.parentNode.replaceChild(newTarget, target)
      target = newTarget

    html = jtmpl(template, model, opts)
    if target.innerHTML isnt html then target.innerHTML = html

    jtmpl(target, model, opts)
</code></pre><p>Default options</p>
<pre><code>jtmpl.defaultOptions = {

  delimiters: &#39;{{ }}&#39;

  compiledDelimiters: &#39;#{ }#&#39;

  defaultSection: &#39;div&#39;

  defaultSectionItem: &#39;div&#39;

  defaultVar: &#39;span&#39;

  defaultPartial: &#39;div&#39;

  defaultTargetTag: &#39;div&#39;
}
</code></pre><p>Construct options object by merging default and specified options    </p>
<pre><code>jtmpl.options = (options, rootModel) -&gt;
  options = options or {}
  opts = JSON.parse(JSON.stringify(jtmpl.defaultOptions))
  for prop of Object.getOwnPropertyNames(options)
    opts[prop] = options[prop]
  # if typeof options.delimiters is &#39;string&#39;
  opts.delimiters = opts.delimiters.split(&#39; &#39;)
  # if typeof options.compiledDelimiters is &#39;string&#39;
  opts.compiledDelimiters = opts.compiledDelimiters.split(&#39; &#39;)
  opts.rootModel = if options.rootModel then options.rootModel else rootModel
  opts
</code></pre><h2 id="requests-api">Requests API</h2>
<pre><code>jtmpl.xhr = (args) -&gt;
  xhr = new XMLHttpRequest()

  callback = args.reduce(
    (prev, curr) -&gt; if typeof curr is &#39;function&#39; then curr else prev,
    null
  )

  opts = args[args.length - 1]
  if typeof opts isnt &#39;object&#39; then opts = {}
  for prop in Object.getOwnPropertyNames(opts)
    xhr[prop] = opts[prop]

  request =
    if typeof args[2] is &#39;string&#39;
      args[2]
    else if typeof args[2] is &#39;object&#39;
      Object.keys(args[2])
        .map(
          (x) -&gt; &quot;#{ x }=#{ encodeURIComponent(args[2][x]) }&quot;
        )
        .join(&#39;&amp;&#39;)
    else 
      &#39;&#39;

  xhr.onload = (event) -&gt;
    if callback
      try
        resp = JSON.parse(this.responseText)
      catch
        resp = this.responseText
      callback.call(this, resp, event)

  xhr.open(args[0], args[1], opts.async or true, opts.user, opts.password)
  xhr.send(request)
</code></pre><h2 id="rules">Rules</h2>
<p>jtmpl is a processor of rules. </p>
<p>Rules in sequences are in increasing generality order. It&#39;s just like 
<a href="http://learnyouahaskell.com/syntax-in-functions">Haskell pattern matching</a>.</p>
<p>Compilation and binding stages can be extended with new rules,
put them at the beginning:</p>
<p><code>jtmpl.compileRules.unshift({ new compile rule... })</code><br><code>jtmpl.bindRules.unshift({ new binding rule... })</code></p>
<h3 id="regular-expression-atoms">Regular expression atoms</h3>
<p>Used in various matchers</p>
<pre><code>RE_IDENTIFIER = &#39;[\\w\\.\\-]+&#39;
RE_NODE_ID = &#39;^#[\\w\\.\\-]+$&#39;
RE_ANYTHING = &#39;[\\s\\S]*?&#39;
RE_SPACE = &#39;\\s*&#39;
RE_PIPE = &quot;(?: \\| (#{ RE_IDENTIFIER }) )?&quot;
RE_DATA_JT = &#39;(?: ( \\s* data-jt = &quot; [^&quot;]* )&quot; )?&#39;
RE_COLLECTION_TEMPLATE = /^(#|\^)\s([\s\S]*)$/
RE_URL = &#39;\w?\\:?\\/\\/[^\\s&quot;\&#39;]+&#39;
</code></pre><h3 id="pre-processing-rules">Pre-processing rules</h3>
<p>Transformations to clean up template for easier matching</p>
<pre><code>jtmpl.preprocessingRules = [
  # Convert triple mustache (output unescaped var) to alt form
  [&quot;({{) { (#{ RE_IDENTIFIER }) } (}})&quot;, &#39;$1&amp;$2$3&#39;]

  # Strip HTML comments that enclose tokens
  [&quot;&lt;!-- #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } --&gt;&quot;, &#39;$1&#39;]

  # Strip single quotes around html element attributes associated with tokens
  [&quot;(#{ RE_IDENTIFIER })=&#39;({{ #{ RE_IDENTIFIER } }})&#39;&quot;, &#39;$1=$2&#39;]

  # Strip double quotes around html element attributes associated with tags
  [&quot;(#{ RE_IDENTIFIER })=\&quot;({{ #{ RE_IDENTIFIER } }})\&quot;&quot;, &#39;$1=$2&#39;]

  # If tags stand on their own line remove the line, keep the tag only
  [&quot;\\n #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } \\n&quot;, &#39;\n$1\n&#39;],

  [&#39;{{&amp;gt;&#39;, &#39;{{&gt;&#39;]
]
</code></pre><h3 id="formatters-mappings">Formatters, mappings</h3>
<p>None provided by default, put yours like <code>jtmpl.formatters.myFormatter = function (val) {...}</code></p>
<pre><code>jtmpl.formatters = {}
jtmpl.mappings = {}
</code></pre><h3 id="partials">Partials</h3>
<p>Resolve <code>{{&gt;&quot;#partial-id&quot;}}</code> during compiling stage.</p>
<p>jtmpl.partials[&#39;partial-id&#39;] is a template string.</p>
<pre><code>jtmpl.partials = {}
</code></pre><h3 id="compile-rules">Compile rules</h3>
<p>Delimiters in <code>pattern</code>s are replaced with escaped options.delimiters, whitespace - stripped.</p>
<p>Inline tags implement <code>replaceWith</code>, section (block) tags implement <code>contents</code>.</p>
<p>Signatures:</p>
<p>[String, Array] <code>replaceWith</code> (String for each group in pattern, AnyType model)</p>
<p>String <code>bindingToken</code> (String for each group in pattern)</p>
<p>[String, Array] <code>contents</code> (String template, AnyType model, String section, Object options)</p>
<pre><code>jtmpl.compileRules = [
</code></pre><h4 id="-tag-class-class-name-other-classes-"><code>&lt;tag class=&quot;{{class-name}} other-classes&quot;&gt;</code></h4>
<p><code>model[&#39;class-name&#39;]</code> is expected to be boolean</p>
<pre><code>  {
    pattern: &quot;(class=\&quot;? [\\w \\. \\- \\s {{}}]*) {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (pre, prop, model) -&gt;
      val = getValue(model, prop)
      [ # Emit match, and class name if booleanVar
        (pre.search(&#39;{&#39;) is -1 and pre or &#39; &#39;) +
        (typeof val is &#39;boolean&#39; and val and prop or &#39;&#39;)
        ,
        []
      ]

    echoReplaceWith: (pre, prop) -&gt;
      if pre.search(&#39;{&#39;) &gt; - 1 then &quot; {{#{ prop }}}&quot; else null

    bindingToken: (pre, prop) -&gt; &quot;class=#{ prop }&quot;
  }
</code></pre><h4 id="-tag-onevent-handler-"><code>&lt;tag onevent=&quot;{{handler}}&quot;&gt;</code></h4>
<p><code>on</code>-prefixed properties are event handlers.
<code>handler</code> is expected to be a function,
<code>handler</code>&#39;s <code>this</code> is the context in which the handler has been attached.
No need to add <code>onchange</code> handlers, syncing of DOM element values and <code>model</code> is already handled.</p>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: -&gt; [&#39;&#39;, []]

    bindingToken: (event, handler) -&gt; &quot;on#{ event }=#{ handler }&quot;
  }
</code></pre><h4 id="-tag-attr-prop-"><code>&lt;tag attr=&quot;{{prop}}&quot;</code></h4>
<p>When <code>prop</code> is null property is absent, otherwise equals <code>prop</code>.</p>
<p>When <code>prop</code> is boolean, value determines presense of attribute.</p>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (attr, prop, model) -&gt;
      val = getValue(model, prop)
      # null?
      if not val? or val is null
        [&#39;&#39;, []]
      # boolean?
      else if typeof val is &#39;boolean&#39;
        [(if val then attr else &#39;&#39;), []]
      # quoted value
      else
        [&quot;#{ attr }=\&quot;#{ val }\&quot;&quot;, []]

    bindingToken: (attr, prop) -&gt; &quot;#{ attr }=#{ prop }&quot;
  }
</code></pre><h4 id="-inverted_section-"><code>{{^inverted_section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\^ (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultSection&#39;

    lastTag: (model, section) -&gt;
      if Array.isArray(model?[section]) then section else null

    contents: (template, model, section, options) -&gt;
      val = getValue(model, section)

      [
        # Sequence?
        if Array.isArray(val)
          # Render body if array empty
          if not val.length then jtmpl(template, model) else &#39;&#39;
        else
          if not val then jtmpl(template, model) else &#39;&#39;
        ,

        [[&#39;data-jt-0&#39;, compileTemplate(template, options)]]
      ]

    bindingToken: (section) -&gt; &quot;^#{ section }&quot;
  }
</code></pre><h4 id="-section-"><code>{{#section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\# (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$&quot;

    lastTag: (model, section, mapping) -&gt;
      if Array.isArray(model?[section]) then section else null

    wrapper: &#39;defaultSection&#39;

    contents: (template, model, section, mapping, options) -&gt;
      mapping = if model and mapping
        options.rootModel[mapping] or model?[mapping] or jtmpl.mappings[mapping]
      else
        null

      val = getValue(model, section, false, null, null, mapping)

      [ 
        # Sequence?
        if Array.isArray(val)

          # Render body for each item
          (jtmpl(template, item, { asArrayItem: true, rootModel: options.rootModel }) for item in val).join(&#39;&#39;)

        # Context
        else if typeof val is &#39;object&#39;
          jtmpl(template, val, options)

        # as Boolean
        else
          if val then jtmpl(template, model, options) else &#39;&#39;

        [[&#39;data-jt-1&#39;, compileTemplate(template, options)]]
      ]

    bindingToken: (section) -&gt; &quot;##{ section }&quot;
  }
</code></pre><h3 id="-partial-id-or-url-partial"><code>{{&gt;&quot;#partial-id or //url&quot;}}</code> partial</h3>
<pre><code>  {
    pattern: &quot;{{ &gt; \&quot;( (?: \\# #{ RE_IDENTIFIER }) )\&quot; }}&quot;

    wrapper: &#39;defaultPartial&#39;

    replaceWith: (partial, model) -&gt;
      if model
        [
          (
            if document
              jtmpl(document.querySelector(partial)?.innerHTML or jtmpl.partials[partial.slice(1)] or &#39;&#39;, model)
            else
              jtmpl(jtmpl.partials[partial.slice(1)] or &#39;&#39;, model)
          ), []
        ]
      else
        [&#39;&#39;, []]

    bindingToken: (partial) -&gt; &quot;&gt;\&quot;#{ partial }\&quot;&quot;
  }
</code></pre><h4 id="-unescaped_var-"><code>{{&amp;unescaped_var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ &amp; (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, model) -&gt; [getValue(model, prop), []]

    bindingToken: (prop) -&gt; prop
  }
</code></pre><h4 id="-var-"><code>{{var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, formatter, model) -&gt; [escapeHTML(getValue(model, prop, undefined, undefined, model?[formatter] || jtmpl.formatters?[formatter] || null)), []]

    bindingToken: (prop, formatter) -&gt; prop + (if formatter then &#39;|&#39; + formatter else &#39;&#39;)
  }

]
</code></pre><h3 id="bind-rules">Bind rules</h3>
<p>Matching is done on tokenized data-jt items</p>
<p><code>react</code> signature:</p>
<p>Function void (AnyType val) <code>react</code>
(DOMElement node, String for each pattern group, AnyType model, Object options)</p>
<pre><code>jtmpl.bindRules = [
</code></pre><h4 id="-value-checked-selected-var-"><code>value/checked/selected=var</code></h4>
<pre><code>  {
    pattern: &quot;(value | checked | selected) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop,

    react: (node, attr, prop, model) -&gt;
      # attach DOM reactor

      # select option?
      if node.nodeName is &#39;OPTION&#39;
        node.parentNode.addEventListener(&#39;change&#39;, -&gt;
          if model[prop] isnt node.selected then model[prop] = node.selected
        )

      # radio group?
      if node.type is &#39;radio&#39; and node.name
        node.addEventListener(&#39;change&#39;, -&gt;
          if node[attr]
            for input in document.querySelectorAll(&quot;input[type=radio][name=#{ node.name }]&quot;)
              if input isnt node
                input.dispatchEvent(new Event(&#39;change&#39;))
          model[prop] = node[attr]
        )

      # text input?
      if node.type in [&#39;text&#39;, &#39;password&#39;]
        node.addEventListener(&#39;input&#39;, -&gt; model[prop] = node[attr])

      # other inputs
      else
        node.addEventListener(&#39;change&#39;, -&gt; model[prop] = node[attr])

      reaction = (val) -&gt;
        val = getValue(model, prop, true, reactor)
        if val is undefined then return

        if node[attr] isnt val then node[attr] = val

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }
</code></pre><h4 id="onevent-var">onevent=var</h4>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    react: (node, evnt, listener, model, options) -&gt;
      # console.log(&#39;on&#39;)
      handler = options?.rootModel?[listener] or model[listener]
      if typeof handler is &#39;function&#39;
        key = evnt + listener
        # listener already attached?
        for pair in model.__jt__.domListeners[key] or []
          if pair[0] is node then return

        node.addEventListener(evnt, handler.bind(model))
        model.__jt__.domListeners[key] ?= []
        model.__jt__.domListeners[key].push([node, evnt, handler])

      else
        throw &quot;:( #{ listener } is not a function, cannot attach event handler&quot;

      # job done, no reactor to return
      null
  }
</code></pre><h4 id="class-var">class=var</h4>
<pre><code>  {
    pattern: &quot;class = (#{ RE_IDENTIFIER })&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, model) -&gt;
      reaction = (val) -&gt;
        (val and addClass or removeClass)(node, prop)

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }
</code></pre><h4 id="attr-var">attr=var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop

    react: (node, attr, prop, model) -&gt;
      reaction = (val) -&gt;
        if node[attr] isnt val then node[attr] = val

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction))

      reactor
  }
</code></pre><h4 id="section">section</h4>
<pre><code>  {
    pattern: &quot;^(# | \\^) (#{ RE_IDENTIFIER }) #{ RE_PIPE } $&quot;

    bindTo: (sectionType, prop) -&gt; prop

    # context for recursion
    recurseContext: (sectionType, attr, mapping, model) -&gt;
      val = model[attr]
      if Array.isArray(val)
        null
      else if typeof val is &#39;object&#39;
        val
      else
        model

    react: (node, sectionType, prop, mapping, model, options) -&gt;
      @index = (@index or 0) + 1

      mapping = options.rootModel[mapping] or model[mapping] or jtmpl.mappings[mapping]
      val = getValue(model, prop, false, null, null, mapping)

      opts = jtmpl.options(options)

      if Array.isArray(val) and sectionType is &#39;#&#39;
        jtmpl.bindArrayToNodeChildren(model, prop, node, options)
        # bind collection items to node children
        for child, i in node.children
          if typeof val[i] is &#39;object&#39;
            jtmpl.bind(child, val[i], opts)

      reaction = (val) -&gt;
        # collection?
        if Array.isArray(val)
          jtmpl.bindArrayToNodeChildren(model, prop, node, opts)

          node.innerHTML =
            if not val.length
              jtmpl(decompileTemplate(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;, opts), model)
            else 
              &#39;&#39;

          node.appendChild(jtmpl.createSectionItem(node, item, opts)) for item in val

        # local context or if section
        else
          if typeof val is &#39;object&#39;
            if Object.getOwnPropertyNames(val).length
              node.innerHTML = jtmpl(
                decompileTemplate(node.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;, opts),
                val,
                opts
              )
              jtmpl.unbind(model[prop])
              jtmpl.bind(node, model, opts)

          else
            node.innerHTML = jtmpl(
              decompileTemplate(
                if sectionType is &#39;#&#39; and val
                  node.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;
                else if sectionType is &#39;^&#39; and not val
                  node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;
                else
                  &#39;&#39;
                ,
                opts
              ),
              model,
              opts
            )

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction, mapping))

      reactor
  }
</code></pre><h4 id="partial">partial</h4>
<pre><code>  {
    pattern: &#39;&gt;&quot;(.*?)&quot;&#39;

    bindTo: (partial) -&gt; null

    react: (node, partial, model, options) -&gt;
      # console.log(&#39;bind partial&#39;)
      # partial resolved during compiling phase?
      if not node.innerHTML

        # template_element.innerHTML?
        if partial.match(RE_NODE_ID)
          node.innerHTML = jtmpl(partial, model, options)

        # fetch template from URL
        if partial.match(RE_URL)
          jtmpl(&#39;GET&#39;, partial, ((resp) -&gt; node.innerHTML = resp))

      (val) -&gt;
        console.log(&#39;partial react&#39;)
        console.log(val)
  }
</code></pre><h4 id="var">var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) #{ RE_PIPE }&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, formatter, model, options) -&gt;
      reaction = (val) -&gt;
        node.innerHTML = (options.rootModel?[formatter] or model[formatter] or jtmpl.formatters?[formatter] or ((x) -&gt; x))(val)
        if typeof val is &#39;object&#39; then jtmpl.bind(node, model, options)

      reactor = (val) -&gt;
        if val isnt undefined then reaction(val)

      if typeof model[prop] is &#39;function&#39; then reactor(getValue(model, prop, true, reaction, formatter))

      reactor
  }



]
</code></pre><h2 id="compile-rules-processor">Compile rules processor</h2>
<h3 id="compile-routine">Compile routine</h3>
<p>Tokenize template and apply each rule on tokens.
Rules can be inline or recursive, end block is hardcoded as &quot;{{/block}}&quot;.
Current delimiters are respected.</p>
<p>String  template
AnyType model
String  openTag
Boolean echoMode
Array   delimiters
Boolean asArrayItem</p>
<pre><code>jtmpl.compile = (template, model, openTag, echoMode, options, asArrayItem) -&gt;

  tokenizer = regexp(&quot;{{ (\/?) (#{ RE_ANYTHING }) }}&quot;, options.delimiters)
  result = &#39;&#39;
  pos = 0

  while (token = tokenizer.exec(template))

    # End block?
    if token[1]
      if token[2] isnt openTag
        throw new Error(openTag and
          &quot;:( expected {{/#{ openTag }}}, got {{#{ token[2] }}}&quot; or
          &quot;:( unexpected {{/#{ token[2] }}}&quot;)

      # Exit recursion
      return result + template.slice(pos, tokenizer.lastIndex - token[0].length)

    slice = template.slice(Math.max(0, pos - 128), tokenizer.lastIndex)

    # Process rules
    for rule in jtmpl.compileRules

      match = regexp(rule.pattern, options.delimiters).exec(slice)
      if match
        # accumulate output
        result += template.slice(pos, tokenizer.lastIndex - match[0].length)

        # inject token in data-jt attr
        htagPos = lastOpenedHTMLTag(result)
        bindingToken = rule.bindingToken(match.slice(1)...)

        # inline tag or section?
        if rule.replaceWith?
          if echoMode
            result += rule.echoReplaceWith?(match.slice(1)...) or match[0]
          else
            [replaceWith, wrapperAttrs] =
              rule.replaceWith(match.slice(1).concat([model])...)

            if htagPos is -1 and rule.wrapper?
              # wrapping needed
              tag = options[rule.wrapper]
              result += injectAttributes(
                injectTagBinding(&quot;&lt;#{ tag }&gt;#{ replaceWith }&lt;/#{ tag }&gt;&quot;, bindingToken),
                wrapperAttrs
              )
            else
              result += replaceWith
              result = result.slice(0, htagPos) + injectAttributes(
                injectTagBinding(result.slice(htagPos), bindingToken),
                wrapperAttrs
              )

          pos = tokenizer.lastIndex

        else
          # Recursively get nested template (echoMode=on)
          tmpl = jtmpl.compile(
            template.slice(tokenizer.lastIndex), 
            model, match[1], true, options)

          # Skip block contents
          tokenizer.lastIndex += tmpl.length

          # Match close block token
          closing = tokenizer.exec(template)
          pos = tokenizer.lastIndex

          if echoMode
            result += token[0] + tmpl + closing[0]
          else
            section = match[1]
            args = [tmpl, model].concat(match.slice(1)).concat([options])
            [contents, wrapperAttrs] = rule.contents(args...)

            if htagPos is -1
              tag = options[rule.wrapper]

              if section isnt lastSectionTag
                lastSectionHTagPos = result.length
                result += injectAttributes(
                  injectTagBinding(&quot;&lt;#{ tag }&gt;#{ contents }&lt;/#{ tag }&gt;&quot;, bindingToken),
                  wrapperAttrs
                )
              else
                result = (
                  result.slice(0, lastSectionHTagPos) +
                  injectAttributes(
                    injectTagBinding(result.slice(lastSectionHTagPos), bindingToken),
                    wrapperAttrs,
                    contents.trim()
                  )
                )

            else
              result = (
                result.slice(0, htagPos) + 
                injectAttributes(
                  injectTagBinding(result.slice(htagPos), bindingToken),
                  wrapperAttrs
                ) +
                contents.trim()
              )
              lastSectionHTagPos = htagPos

            lastSectionTag = rule.lastTag?(model, section) or null


        # Match was found, skip other rules
        break

  result += template.slice(pos)

  # Return accumulated output
  if options.asArrayItem

    # enclose in defaultSectionItem HTML tag if needed
    if isValidHTMLTag(result)
      result 
    else
      tag = options.defaultSectionItem
      &quot;&lt;#{ tag }&gt;#{ result }&lt;/#{ tag }&gt;&quot;

  else
    result
</code></pre><h3 id="compiling-stage-supporting-utilities">Compiling stage supporting utilities</h3>
<p>String addTagBinding(String, String)</p>
<p>Inject token in HTML element data-jt attribute.
Create attribute if not existent.
wrapperAttrs is array of pairs [attribute, value] to inject in element</p>
<pre><code>injectTagBinding = (template, token) -&gt;
  # group 1: &#39;data-jt&#39; inject position
  # group 2: token inject position, if attribute exists
  # group 3 (RE_DATA_JT): existing &#39;data-jt&#39; value
  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER }) (#{ RE_ANYTHING }) #{ RE_DATA_JT }&quot;).exec(template)
  attrLen = (match[3] or &#39;&#39;).length
  pos = match[1].length + match[2].length + attrLen
  token = escapeHTML(token)
  # inject, return result
  ( template.slice(0, pos) +
    ( if attrLen
        (if match[3].trim() is &#39;data-jt=&quot;&#39; then &#39;&#39; else &#39; &#39;) + token
      else
        &#39; data-jt=&quot;&#39; + token + &#39;&quot;&#39;
    ) +
    template.slice(pos)
  )

injectAttributes = (template, attributes, contents) -&gt;
  if not attributes.length then return template

  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER } #{ RE_ANYTHING })&gt;&quot;).exec(template)
  pos = match[1].length
  (
    template.slice(0, pos) + 
    [&quot; #{ pair[0] }=\&quot;#{ escapeHTML(pair[1]) }\&quot;&quot; for pair in attributes].join(&#39;&#39;) +
    &#39;&gt;&#39; +
    (contents or &#39;&#39;) +
    template.slice(pos + 1)
  )
</code></pre><p>Int lastOpenedHTMLTag(String)</p>
<p>Return index of the last opening, maybe opened (no close bracket), HTML tag
followed by end of string, or -1, if no such exists</p>
<pre><code>lastOpenedHTMLTag = (template) -&gt;
  template.trimRight().search(regexp(&quot;&lt; #{ RE_IDENTIFIER } [^&gt;]*? &gt;?$&quot;))
</code></pre><p>Boolean isValidHTMLTag(String)</p>
<p>Check if contents is properly formatted closed HTML tag</p>
<pre><code>isValidHTMLTag = (contents) -&gt;
  !!contents.trim().match(regexp(&quot;^&lt;(#{ RE_IDENTIFIER }) #{ RE_SPACE }
    [^&gt;]*? &gt; #{ RE_ANYTHING } &lt;/\\1&gt;$ | &lt; [^&gt;]*? /&gt;$&quot;)
  )
</code></pre><h2 id="post-binding-stage">Post-binding stage</h2>
<p>Init function (<code>model[&#39;#&#39;]</code>) and routes via window onhashchange are processed here.</p>
<p>If route definition contains a &#39;(&#39;, then it&#39;s considered regular expression
and groups are passed as parameters to the route handler.</p>
<p>Example routes:</p>
<p><code>&#39;#simple-route&#39;: function () { ...</code></p>
<p><code>&#39;#page-(\\d+)&#39;: function (pageNumber) { ...</code></p>
<pre><code>jtmpl.postbind = (model) -&gt;
  if typeof model[&#39;#&#39;] is &#39;function&#39;
    model[&#39;#&#39;].apply(model)

  props = Object.getOwnPropertyNames(model)
  routes = props.filter((prop) -&gt; regexp(&quot;##{ RE_ANYTHING }&quot;).exec(prop))

  if routes.length and window
    hashchange = -&gt; 
      for route in routes
        if &#39;(&#39; in route
          match = new RegExp(route, &#39;g&#39;).exec(window.location.hash)
          if match and typeof model[route] is &#39;function&#39;
            model[route].apply(model, match.slice(1))
        else
          if route is window.location.hash and typeof model[route] is &#39;function&#39;
            model[route].apply(model)
      return

    hashchange()

    if not model.__jt__.domListeners[&#39;hashchange&#39;]
      window.addEventListener(&#39;hashchange&#39;, hashchange)
      model.__jt__.domListeners[&#39;hashchange&#39;] = true
</code></pre><h2 id="bind-rules-processor">Bind rules processor</h2>
<p>void <code>bind</code> (DOMElement root, AnyType model)</p>
<p>Walk DOM and setup reactors on model and nodes.</p>
<pre><code>jtmpl.bind = (node, model, options, nodeCounter) -&gt;

  # Initialize bookkeeping
  if typeof model is &#39;object&#39; and not model.__jt__ 
    model.__jt__ = {
      dependents: {},
      listeners: {},
      domListeners: {},
      bound: {}
    }

  nodeCounter = (nodeCounter or 0) + 1

  if data_jt = node.getAttribute(&#39;data-jt&#39;)
    # iterate bindings
    for jt in data_jt.trim().split(&#39; &#39;)

      for rule in jtmpl.bindRules

        if match = regexp(rule.pattern).exec(jt)

          reactor = rule.react.apply(rule, [node].concat(match.slice(1), [model, options]))
          prop = rule.bindTo?(match.slice(1)...)

          key = prop + rule.pattern + jt + nodeCounter

          # This rule already applied? bind must be idempotent
          if not model?.__jt__.bound[key]
            propChange(model, prop, reactor)

          if typeof model is &#39;object&#39;
            model.__jt__.bound[key] = true

          recurseContext = rule.recurseContext?(match.slice(1).concat([model])...)

          break

  if recurseContext isnt null
    for child in node.children
      nodeCounter += 1
      jtmpl.bind(child, recurseContext or model, options, nodeCounter)



jtmpl.unbind = (model) -&gt;
  if typeof model?.__jt__?.domListeners is &#39;object&#39;
    for key, listeners of model.__jt__.domListeners
      for listener in listeners
        listener[0].removeEventListener(listener[1], listener[2])
    model.__jt__.domListeners = {}
</code></pre><h2 id="supporting-code">Supporting code</h2>
<h3 id="regular-expression-utilities">Regular expression utilities</h3>
<p>String escapeRE(String s)</p>
<p>Escape regular expression characters</p>
<pre><code>escapeRE = (s) -&gt; (s + &#39;&#39;).replace(/([.?*+^$[\]\\(){}|-])/g, &#39;\\$1&#39;)
</code></pre><p>RegExp regexp(String src, Object options)</p>
<p>Replace mustaches with given delimiters, strip whitespace, return RegExp</p>
<pre><code>regexp = (src, delimiters) -&gt;
  # strip whitespace
  src = src.replace(/\s+/g, &#39;&#39;)
  new RegExp((if delimiters then src
    .replace(&#39;{{&#39;,  escapeRE(delimiters[0]))
    .replace(&#39;}}&#39;,  escapeRE(delimiters[1]))
    else src)
  , &#39;g&#39;)
</code></pre><p>AnyType getValue(AnyType model, String prop[, Function callback[, Function self]])</p>
<p>Get value of <code>model[prop]</code>, evaluate value function if computed value</p>
<p>When <code>model[prop]</code> is function, it should use <code>this</code> to refer to model properties,
like <code>this(&#39;foo&#39;)</code> or even <code>@ &#39;foo&#39;</code> in CoffeeScript. </p>
<p>When in <code>trackDependencies</code> mode:</p>
<p>value function can compute the result asynchronously,
return undefined to signal this, finally call <code>callback</code> with computed value on success.</p>
<p><code>model.__jt__.dependents[prop]</code> registers all descendents for a <code>prop</code></p>
<pre><code>getValue = (model, prop, trackDependencies, callback, formatter, mapping) -&gt;
  if model is null or model is undefined or prop is null or prop is undefined then return null

  formatter = formatter or (x) -&gt; x

  getter = (prop) -&gt;
    result = model[prop]
    formatter(
      if typeof result is &#39;function&#39;
        result.call(getter)
      else
        result
    )

  dependencyTracker = (propToReturn) -&gt;
    model.__jt__.dependents[propToReturn] ?= []
    if model.__jt__.dependents[propToReturn].indexOf(prop) is -1
      model.__jt__.dependents[propToReturn].push(prop)
    getter(propToReturn)

  if prop is &#39;.&#39; then return formatter(model)

  val = model[prop]
  result = 
    if typeof val is &#39;function&#39;
      val.call(
        # `this` function
        if trackDependencies then dependencyTracker else getter
        ,
        callback
      )
    else
      formatter(val)

  if typeof mapping is &#39;function&#39; and Array.isArray(result)
    result.map(mapping).filter(isDefined)
  else
    result


isDefined = (x) -&gt; x isnt null and x isnt undefined
</code></pre><h3 id="string-utilities">String utilities</h3>
<p>String escapeHTML(String val)</p>
<p>Replace HTML special characters</p>
<pre><code>escapeHTML = (val) -&gt;
  (val? and val or &#39;&#39;)
    .toString()
    .replace /[&amp;&quot;&lt;&gt;\\]/g, (s) -&gt; { 
        &#39;&amp;&#39;: &#39;&amp;amp;&#39;
        &#39;\\&#39;: &#39;\\\\&#39;
        &#39;&quot;&#39;: &#39;&amp;quot;&#39;
        &#39;&lt;&#39;: &#39;&amp;lt;&#39;
        &#39;&gt;&#39;: &#39;&amp;gt;&#39;
      }[s]
</code></pre><p>String multiReplace(String template, Array from, Array to)</p>
<p>Replace <code>from</code> literal strings with <code>to</code> strings in template</p>
<pre><code>multiReplace = (template, from, to) -&gt;
  for find, i in from
    template = template.replace(regexp(escapeRE(find)), to[i])
  template


compileTemplate = (template, options) -&gt;
  multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)


decompileTemplate = (template, options) -&gt;
  multiReplace(template.trim(), options.compiledDelimiters, options.delimiters)
</code></pre><h3 id="dom-utilities">DOM utilities</h3>
<p>DOMElement createSectionItem (DOMElement parent, AnyType context)</p>
<pre><code>jtmpl.createSectionItem = createSectionItem = (parent, context, options) -&gt;
  if context is undefined then context = {}
  element = document.createElement(&#39;body&#39;)
  element.innerHTML = jtmpl(
    multiReplace(parent.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;,
      options.compiledDelimiters, options.delimiters),
    context
  )
  element = element.children[0]
  if typeof context is &#39;object&#39;
    jtmpl(element, element.innerHTML, context, options)
  element

jtmpl.hasClass = hasClass = (el, name) -&gt; new RegExp(&quot;(\\s|^)#{ name }(\\s|$)&quot;).test(el.className)

jtmpl.addClass = addClass = (el, name) -&gt; 
  if not hasClass(el, name) then el.className += (el.className and &#39; &#39; or &#39;&#39;) + name

jtmpl.removeClass = removeClass = (el, name) -&gt;
  if hasClass(el, name) then el.className = el.className
    .replace(new RegExp(&quot;(\\s|^)#{name}(\\s|$)&quot;), &#39;&#39;)
    .replace(/^\s+|\s+$/g, &#39;&#39;)
</code></pre><h3 id="binding-utilities">Binding utilities</h3>
<p>void propChange(Object obj, String prop, Function callback)</p>
<p>Register a callback to handle object property change. </p>
<pre><code>propChange = (obj, prop, callback) -&gt;
  # All must be specified, don&#39;t fail if not
  if not (obj and prop and callback) then return

  # If property to bind to is not existent
  if obj[prop] is undefined then obj[prop] = null

  # We have listeners for this object property?
  if Array.isArray(obj.__jt__.listeners[prop])
    obj.__jt__.listeners[prop].push(callback)
    return

  obj.__jt__.listeners[prop] = [callback]

  catchSignal = (val) -&gt;
    if signal = val?.__signal__
      val = getValue(signal.obj, signal.prop, true, callback)
      if val isnt undefined then callback(val)
      true
    else
      false

  value = obj[prop]

  Object.defineProperty(obj, prop, {
    get: -&gt; value,
    set: (val) -&gt;
      # console.log(&#39;set &#39; + prop)
      if not catchSignal(val)
        if typeof value is &#39;function&#39;
          # computed value
          value.call(((p, val) -&gt; obj[p] = val), val)
        else
          # simple value
          value = val

        # notify listeners
        for cb in obj.__jt__.listeners[prop]
          # console.log(&#39;notify &#39; + prop + &#39; listener&#39;)
          cb(val)

      alertDependents(obj, prop)
    ,
    configurable: true,
    enumerable: false
  })



alertDependents = (obj, prop) -&gt;
  for dependent in obj.__jt__.dependents[prop] or []
    if typeof dependent is &#39;function&#39;
      # onchange subscriber
      dependent()
    else
      # dependent property
      obj[dependent] = {
        __signal__: {
          obj: obj,
          prop: dependent
        }
      }
  return
</code></pre><p>void bindArrayToNodeChildren(Array array, DOMElement node)</p>
<p>Bind an array to DOM node, 
so when array is modified, node children are updated accordingly.</p>
<p>Array is augmented by attaching listeners on existing indices
and setting a proxy for each mutable operation. 
<code>createSectionItem</code> is used for creating new items.</p>
<pre><code>jtmpl.bindArrayToNodeChildren = (model, prop, node, options) -&gt;

  array = model[prop]

  # array already augmented?
  if not array.__values

    # Mutable array operations decorator
    mutable = (method) -&gt;
      -&gt;
        # remove &lt;empty&gt; element
        if not @length
          for node in @__nodes
            node.innerHTML = &#39;&#39;

        # it&#39;s possible for a referenced node to be destroyed. garbage collect references
        i = @__nodes.length
        while --i
          if not @__nodes[i].parentNode
            @__nodes.splice(i, 1)

        # call mutable method
        result = method.apply(this, arguments)

        # add &lt;empty&gt; element
        if not this.length
          for node in @__nodes
            node.innerHTML = jtmpl(
              multiReplace(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;,
                options.compiledDelimiters, options.delimiters),
              {}
            )

        # recompute whatever
        alertDependents(model, prop)

        # what method returned
        result

    # Proxy all mutable operations
    for operation, proxy of {
      pop: -&gt;
        if @length
          node.removeChild(node.children[node.children.length - 1]) for node in @__nodes
        [].pop.apply(@, arguments)

      push: (item) -&gt;
        node.appendChild(createSectionItem(node, item, options)) for node in @__nodes
        result = [].push.apply(@, arguments)
        bindProp(item, @length - 1)
        result

      reverse: -&gt;
        for node in @__nodes
          node.innerHTML = &#39;&#39;
          for item, i in @ by -1
            node.appendChild(createSectionItem(node, item, options))
            bindProp(item, i)
        [].reverse.apply(@, arguments)

      shift: -&gt;
        for node in @__nodes
          node.removeChild(node.children[0])
        result = [].shift.apply(@, arguments)
        for item, i in @
          bindProp(item, i)
        result

      unshift: -&gt;
        for item in [].slice.call(arguments).reverse()
          for node in @__nodes
            node.insertBefore(createSectionItem(node, item, options), node.children[0])
        result = [].unshift.apply(@, arguments)
        for item, i in @
          bindProp(item, i)
        result

      sort: -&gt;
        [].sort.apply(@, arguments)
        for node in @__nodes
          node.innerHTML = &#39;&#39;
          for item, i in @
            node.appendChild(createSectionItem(node, item, options))
            bindProp(item, i)
        @

      splice: (index, howMany) -&gt;
        for node in @__nodes
          for i in [0...howMany]
            node.removeChild(node.children[index])
          for item in [].slice.call(arguments, 2)
            node.insertBefore(createSectionItem(node, item, options), node.children[index])
            bindProp(item, index)
        [].splice.apply(@, arguments)
    }
      array[operation] = mutable(proxy)


    # Bind property
    bindProp = (item, i) -&gt;
      array.__values[i] = item
      Object.defineProperty(array, i, 
        get: -&gt; @__values[i]
        set: mutable(
          (val) -&gt; 
            @__values[i] = val
            node.replaceChild(createSectionItem(node, val, options), node.children[i]) for node in @__nodes
        )
      )

    # bound nodes
    Object.defineProperty(array, &#39;__nodes&#39;,
      enumerable: false
      writable: true
      value: []
    )
    # onchange handlers for each item
    Object.defineProperty(array, &#39;__values&#39;,
      enumerable: false
      writable: true
      value: []
    )
    for item, i in array
      bindProp(item, i)

  if array.__nodes.indexOf(node) is -1 then array.__nodes.push(node)
  array
</code></pre>
          <footer>
              <span>{&rsaquo;</span> Copyright &copy; 2013-2014 Atanas Minev, <a href="LICENSE">MIT license</a>
          </footer>
        </div>
        <script src="/js/highlight.min.js"></script>
        <script src="/js/highlight-coffee.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-43285803-1', 'jtmpl.com');
          ga('send', 'pageview');
        </script>
    </body>
</html>