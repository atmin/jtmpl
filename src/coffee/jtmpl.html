<!doctype html>
<html>
    <head>
        <link rel="stylesheet" href="/css/styles.css">
        <link rel="stylesheet" href="/css/highlight.css">
        <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css">
        <script src="/js/jtmpl.js"></script>
        <title>jtmpl</title>
    </head>
    <body>
        <div class="wrapper">
          <h1><span>{<span>&rsaquo;</span></span> <a href="/">jtmpl</a> <sup>0.2.0</sup></h1>
          <h2 id="introduction">Introduction</h2>
<p>jtmpl is written in <a href="http://ashkenas.com/literate-coffeescript/">Literate CoffeeScript</a>.
Production version is generated by extracting the code, compiling and minifying it via UglifyJS.</p>
<p>This documentation is currently a draft.</p>
<h2 id="interface">Interface</h2>
<p>Compile (works in NodeJS and browser): jtmpl(String template, AnyType model)</p>
<p>Compile (if needed) and bind (browser only):</p>
<p>void jtmpl(DOMElement target, String template, AnyType model)</p>
<p><code>target</code> and <code>template</code> can be Strings in the format &quot;#element-id&quot;.</p>
<h3 id="main-function">Main function</h3>
<p>Target NodeJS and browser</p>
<pre><code>jtmpl = (exports ? this).jtmpl = (target, template, model, options) -&gt;

  # Deprecated. `jtmpl(selector)`?
  if (target is null or typeof target is &#39;string&#39;) and not template?

    if not document?
      throw new Error(&#39;:( this API is only available in a browser&#39;)

    return ap.slice.call(document.querySelectorAll(target))

  # `jtmpl(template, model)`?
  if typeof target is &#39;string&#39; and
      typeof template in [&#39;number&#39;, &#39;string&#39;, &#39;boolean&#39;, &#39;object&#39;] and
      (model is undefined or model is null)

    model = template
    template = target
    target = undefined

  # `jtmpl(&#39;#element-id&#39;, ...)`?
  if typeof target is &#39;string&#39; and target.match(RE_NODE_ID)
    target = document.getElementById(target.substring(1))

  if not model?
    throw new Error(&#39;:( no model&#39;)

  # `jtmpl(&#39;#template-id&#39;, ...)` or `jtmpl(element, &#39;#template-id&#39;, ...)`      
  if template.match and template.match(RE_NODE_ID)
    template = document.getElementById(template.substring(1)).innerHTML

  # options
  options = options or {}

  # string-separated opening and closing delimiter
  options.delimiters = (
    if Array.isArray(options.delimiters)
      options.delimiters.join(&#39; &#39;)
    else
      options.delimiters or &#39;{{ }}&#39;
  ).split(&#39; &#39;)
  # delimiters are changed in the generated HTML comment-enclosed section prototype
  # to avoid double-parsing
  options.compiledDelimiters = (
    if Array.isArray(options.compiledDelimiters)
      options.compiledDelimiters.join(&#39; &#39;)
    else
      options.compiledDelimiters or  &#39;#{ }#&#39;
  ).split(&#39; &#39;)

  # sections not enclosed in HTML tag are automatically enclosed
  options.defaultSection = options.defaultSectionTag or &#39;div&#39;
  # default for section items
  options.defaultSectionItem = options.defaultSectionItem or &#39;div&#39;
  # default for section items
  options.defaultVar = options.defaultVar or &#39;span&#39;

  # default target tag
  options.defaultTargetTag = options.defaultTargetTag or &#39;div&#39;

  delimiters = options.delimiters

  ## Preprocess template
  template = (&#39;&#39; + template)
    # Convert triple mustache (output unescaped var) to alt form
    .replace(regexp(&quot;{{{ (#{ RE_IDENTIFIER }) }}}&quot;), delimiters[0] + &#39;&amp;$1&#39; + delimiters[1])
    # Strip HTML comments that enclose tokens
    .replace(regexp(&quot;&lt;!-- #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } --&gt;&quot;, delimiters), &#39;$1&#39;)
    # Strip single quotes around html element attributes associated with tokens
    .replace(regexp(&quot;(#{ RE_IDENTIFIER })=&#39;({{ #{ RE_IDENTIFIER } }})&#39;&quot;, delimiters), &#39;$1=$2&#39;)
    # Strip double quotes around html element attributes associated with tags
    .replace(regexp(&quot;(#{ RE_IDENTIFIER })=\&quot;({{ #{ RE_IDENTIFIER } }})\&quot;&quot;, delimiters), &#39;$1=$2&#39;)
    # If tags stand on their own line remove the line, keep the tag only
    .replace(regexp(&quot;\\n #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } \\n&quot;, delimiters), &#39;\n$1\n&#39;)

  # Compile template
  html = jtmpl.compile(template, model, null, false, options).trim()

  # Done?
  if not target then return html

  if target.nodeName is &#39;SCRIPT&#39;
    newTarget = document.createElement(options.defaultTargetTag)
    target.parentNode.replaceChild(newTarget, target)
    target = newTarget

  # Construct DOM
  target.innerHTML = html

  # Bind recursively using data-jt attributes
  options.rootModel ?= model
  jtmpl.bind(target, model, options)</code></pre>
<h2 id="rules">Rules</h2>
<p>jtmpl is a processor of rules. </p>
<p>Rules in sequences are in increasing generality order. It&#39;s just like 
<a href="http://learnyouahaskell.com/syntax-in-functions">Haskell pattern matching</a>.</p>
<p>Compilation and binding stages can be extended with new rules,
put them at the beginning:</p>
<p><code>jtmpl.compileRules.unshift({ new compile rule... })</code><br><code>jtmpl.bindRules.unshift({ new binding rule... })</code></p>
<h3 id="regular-expression-atoms">Regular expression atoms</h3>
<p>Used in various matchers</p>
<pre><code>RE_IDENTIFIER = &#39;[\\w\\.\\-]+&#39;
RE_NODE_ID = &#39;^#[\\w\\.\\-]+$&#39;
RE_ANYTHING = &#39;[\\s\\S]*?&#39;
RE_SPACE = &#39;\\s*&#39;
RE_DATA_JT = &#39;(?: ( \\s* data-jt = &quot; [^&quot;]* )&quot; )?&#39;
RE_COLLECTION_TEMPLATE = /^(#|\^)\s([\s\S]*)$/</code></pre>
<h3 id="pre-processing-rules">Pre-processing rules</h3>
<p>Transformations to clean up template for easier matching</p>
<pre><code>jtmpl.preprocessingRules = [

  { pattern: &quot;&quot;, replaceWith: &quot;&quot; }
]</code></pre>
<h3 id="compile-rules">Compile rules</h3>
<p>Delimiters in <code>pattern</code>s are replaced with escaped options.delimiters, whitespace - stripped.</p>
<p>Inline tags implement <code>replaceWith</code>, section (block) tags implement <code>contents</code>.</p>
<p>Signatures:</p>
<p>[String, Array] <code>replaceWith</code> (String for each group in pattern, AnyType model)</p>
<p>String <code>bindingToken</code> (String for each group in pattern)</p>
<p>[String, Array] <code>contents</code> (String template, AnyType model, String section, Object options)</p>
<pre><code>jtmpl.compileRules = [</code></pre>
<h4 id="-tag-class-class-name-other-classes-"><code>&lt;tag class=&quot;{{class-name}} other-classes&quot;&gt;</code></h4>
<p><code>model[&#39;class-name&#39;]</code> is expected to be boolean</p>
<pre><code>  {
    pattern: &quot;(class=\&quot;? [\\w \\. \\- \\s {{}}]*) {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (pre, prop, model) -&gt;
      val = model[prop]
      [ # Emit match, and class name if booleanVar
        (pre.search(&#39;{&#39;) is -1 and pre or &#39; &#39;) +
        (typeof val is &#39;boolean&#39; and val and prop or &#39;&#39;)
        ,
        []
      ]

    echoReplaceWith: (pre, prop) -&gt;
      if pre.search(&#39;{&#39;) &gt; - 1 then &quot; {{#{ prop }}}&quot; else null

    bindingToken: (pre, prop) -&gt; &quot;class=#{ prop }&quot;
  }</code></pre>
<h4 id="-tag-onevent-handler-"><code>&lt;tag onevent=&quot;{{handler}}&quot;&gt;</code></h4>
<p><code>on</code>-prefixed properties are event handlers.
<code>handler</code> is expected to be a function,
<code>handler</code>&#39;s <code>this</code> is the context in which the handler has been attached.
No need to add <code>onchange</code> handlers, syncing of DOM element values and <code>model</code> is already handled.</p>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: -&gt; [&#39;&#39;, []]

    bindingToken: (event, handler) -&gt; &quot;on#{ event }=#{ handler }&quot;
  }</code></pre>
<h4 id="-tag-attr-prop-"><code>&lt;tag attr=&quot;{{prop}}&quot;</code></h4>
<p>When <code>prop</code> is null property is absent, otherwise equals <code>prop</code>.</p>
<p>When <code>prop</code> is boolean, value determines presense of attribute.</p>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$&quot;

    replaceWith: (attr, prop, model) -&gt;
      val = model[prop]
      # null?
      if not val? or val is null
        [&#39;&#39;, []]
      # boolean?
      else if typeof val is &#39;boolean&#39;
        [(if val then attr else &#39;&#39;), []]
      # quoted value
      else
        [&quot;#{ attr }=\&quot;#{ val }\&quot;&quot;, []]

    bindingToken: (attr, prop) -&gt; &quot;#{ attr }=#{ prop }&quot;
  }</code></pre>
<h4 id="-inverted_section-"><code>{{^inverted_section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\^ (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultSection&#39;

    lastTag: (model, section) -&gt;
      if Array.isArray(model[section]) then section else null

    contents: (template, model, section, options) -&gt;
      val = model[section]

      # Sequence?
      if Array.isArray(val)
        [
          # Render body if array empty
          if not val.length then jtmpl(template, model) else &#39;&#39;
          ,
          [
            [ # template as node data attribute
              &#39;data-jt-0&#39;,

              multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
            ]
          ]
        ]

      else
        [ jtmpl(template, model),
          if val then [[&#39;style&#39;, &#39;display:none&#39;]] else []
        ]
    bindingToken: (section) -&gt; &quot;^#{ section }&quot;
  }</code></pre>
<h4 id="-section-"><code>{{#section}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ \\# (#{ RE_IDENTIFIER }) }}$&quot;

    lastTag: (model, section) -&gt;
      if Array.isArray(model[section]) then section else null

    wrapper: &#39;defaultSection&#39;

    contents: (template, model, section, options) -&gt;
      val = model[section]
      # Sequence?
      if Array.isArray(val)
        [ # Render body for each item
          (jtmpl(template, item, null, { asArrayItem: true }) for item in val).join(&#39;&#39;),
          [ # template as node data attribute
            [
              &#39;data-jt-1&#39;,

              multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
            ]
          ]
        ]

      # Context?
      else if typeof val is &#39;object&#39;
        # Render body using context
        [ jtmpl(template, val),
          []
        ]

      else
        [ jtmpl(template, model),
          if not val then [[&#39;style&#39;, &#39;display:none&#39;]] else []
        ]

    bindingToken: (section) -&gt; &quot;##{ section }&quot;
  }</code></pre>
<h4 id="-unescaped_var-"><code>{{&amp;unescaped_var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ &amp; (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, model) -&gt; [prop is &#39;.&#39; and model or model[prop], []]

    bindingToken: (prop) -&gt; prop
  }</code></pre>
<h4 id="-var-"><code>{{var}}</code></h4>
<pre><code>  {
    pattern: &quot;{{ (#{ RE_IDENTIFIER }) }}$&quot;

    wrapper: &#39;defaultVar&#39;

    replaceWith: (prop, model) -&gt; [escapeHTML(prop is &#39;.&#39; and model or model[prop]), []]

    bindingToken: (prop) -&gt; prop
  }

]</code></pre>
<h3 id="bind-rules">Bind rules</h3>
<p>Matching is done on tokenized data-jt items</p>
<p><code>react</code> signature:</p>
<p>Function void (AnyType val) <code>react</code>
(DOMElement node, String for each pattern group, AnyType model, Object options)</p>
<pre><code>jtmpl.bindRules = [</code></pre>
<h4 id="-value-checked-selected-var-"><code>value/checked/selected=var</code></h4>
<pre><code>  {
    pattern: &quot;(value | checked | selected) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop,

    react: (node, attr, prop, model) -&gt;
      # attach DOM reactor

      # select option?
      if node.nodeName is &#39;OPTION&#39;
        node.parentNode.addEventListener(&#39;change&#39;, -&gt;
          if model[prop] isnt node.selected then model[prop] = node.selected
        )

      # radio group?
      if node.type is &#39;radio&#39; and node.name
        node.addEventListener(&#39;change&#39;, -&gt;
          if node[attr]
            for input in document.querySelectorAll(&quot;input[type=radio][name=#{ node.name }]&quot;)
              if input isnt node
                input.dispatchEvent(new Event(&#39;change&#39;))
          model[prop] = node[attr]
        )

      # text input?
      if node.type is &#39;text&#39;
        node.addEventListener(&#39;input&#39;, -&gt; model[prop] = node[attr])

      # other inputs
      else
        node.addEventListener(&#39;change&#39;, -&gt; model[prop] = node[attr])

      # return model reactor
      (val) -&gt; if node[attr] isnt val then node[attr] = val
  }</code></pre>
<h4 id="onevent-var">onevent=var</h4>
<pre><code>  {
    pattern: &quot;on(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    react: (node, evnt, listener, model, options) -&gt;
      handler = options?.rootModel?[listener] or model[listener]
      if typeof handler is &#39;function&#39;
        node.addEventListener(evnt, handler.bind(model))
      else
        throw &quot;:( #{ listener } is not a function, cannot attach event handler&quot;

      # job done, no reactor to return
      null
  }</code></pre>
<h4 id="class-var">class=var</h4>
<pre><code>  {
    pattern: &quot;class = (#{ RE_IDENTIFIER })&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, model) -&gt;
      (val) -&gt; (val and addClass or removeClass)(node, prop)
  }</code></pre>
<h4 id="attr-var">attr=var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })&quot;

    bindTo: (attr, prop) -&gt; prop

    react: (node, attr) -&gt;
      (val) -&gt; if node[attr] isnt val then node[attr] = val
  }</code></pre>
<h4 id="section">section</h4>
<pre><code>  {
    pattern: &quot;(# | \\^) (#{ RE_IDENTIFIER })&quot;

    bindTo: (sectionType, prop) -&gt; prop

    # context for recursion
    recurseContext: (sectionType, attr, model) -&gt;
      val = model[attr]
      if Array.isArray(val)
        console.log(&#39;no recurseContext&#39;)
        null
      else if typeof val is &#39;object&#39;
        console.log(&#39;recurseContext: &#39; + attr)
        val
      else
        console.log(&#39;recurseContext: model&#39;)
        model

    react: (node, sectionType, attr, model, options) -&gt;
      val = model[attr]

      console.log(&quot;react sectionType=#{ sectionType } attr=#{ attr } val=#{ val }&quot;)

      if Array.isArray(val) and sectionType is &#39;#&#39;
        jtmpl.bindArrayToNodeChildren(val, node, options)
        # bind collection items to node children
        for child, i in node.children
          if typeof val[i] is &#39;object&#39;
            console.log(&#39;binding val[&#39; + i + &#39;]&#39;)
            jtmpl.bind(child, val[i], options)

      # Return reactor function
      (val) -&gt;
        # collection?
        if Array.isArray(val)
          jtmpl.bindArrayToNodeChildren(val, node, options)

          node.innerHTML =
            if not val.length
              jtmpl(
                multiReplace(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;,
                  options.compiledDelimiters, options.delimiters),
                {}
              )
            else 
              &#39;&#39;

          node.appendChild(jtmpl.createSectionItem(node, item, options)) for item in val

        # local context?
        else if typeof val is &#39;object&#39;
          node.innerHTML = jtmpl(
            multiReplace(node.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;,
                options.compiledDelimiters, options.delimiters),
            val
          )
          jtmpl(node, node.innerHTML, val, { rootModel: model })

        # if section
        else
          node.style.display = (!val isnt (sectionType is &#39;^&#39;)) and &#39;none&#39; or &#39;&#39;
  }</code></pre>
<h4 id="var">var</h4>
<pre><code>  {
    pattern: &quot;(#{ RE_IDENTIFIER })&quot;

    bindTo: (prop) -&gt; prop

    react: (node, prop, model, options) -&gt;
      (val) -&gt; 
        node.innerHTML = val
        if typeof val is &#39;object&#39; then jtmpl.bind(node, model, options)
  }

]</code></pre>
<h2 id="compile-rules-processor">Compile rules processor</h2>
<h3 id="compile-routine">Compile routine</h3>
<p>Tokenize template and apply each rule on tokens.
Rules can be inline or recursive, end block is hardcoded as &quot;{{/block}}&quot;.
Current delimiters are respected.</p>
<p>String  template
AnyType model
String  openTag
Boolean echoMode
Array   delimiters
Boolean asArrayItem</p>
<pre><code>jtmpl.compile = (template, model, openTag, echoMode, options, asArrayItem) -&gt;

  tokenizer = regexp(&quot;{{ (\/?) (#{ RE_ANYTHING }) }}&quot;, options.delimiters)
  result = &#39;&#39;
  pos = 0

  while (token = tokenizer.exec(template))

    # End block?
    if token[1]
      if token[2] isnt openTag
        throw new Error(openTag and
          &quot;:( expected {{/#{ openTag }}}, got {{#{ token[2] }}}&quot; or
          &quot;:( unexpected {{/#{ token[2] }}}&quot;)

      # Exit recursion
      return result + template.slice(pos, tokenizer.lastIndex - token[0].length)

    slice = template.slice(Math.max(0, pos - 128), tokenizer.lastIndex)

    # Process rules
    for rule in jtmpl.compileRules

      match = regexp(rule.pattern, options.delimiters).exec(slice)
      if match
        # accumulate output
        result += template.slice(pos, tokenizer.lastIndex - match[0].length)

        # inject token in data-jt attr
        htagPos = lastOpenedHTMLTag(result)
        bindingToken = rule.bindingToken(match.slice(1)...)

        # inline tag or section?
        if rule.replaceWith?
          if echoMode
            result += rule.echoReplaceWith?(match.slice(1)...) or match[0]
          else
            [replaceWith, wrapperAttrs] =
              rule.replaceWith(match.slice(1).concat([model])...)

            if htagPos is -1 and rule.wrapper?
              # wrapping needed
              tag = options[rule.wrapper]
              result += injectAttributes(
                injectTagBinding(&quot;&lt;#{ tag }&gt;#{ replaceWith }&lt;/#{ tag }&gt;&quot;, bindingToken),
                wrapperAttrs
              )
            else
              result += replaceWith
              result = result.slice(0, htagPos) + injectAttributes(
                injectTagBinding(result.slice(htagPos), bindingToken),
                wrapperAttrs
              )

          pos = tokenizer.lastIndex

        else
          # Recursively get nested template (echoMode=on)
          tmpl = jtmpl.compile(
            template.slice(tokenizer.lastIndex), 
            model, match[1], true, options)

          # Skip block contents
          tokenizer.lastIndex += tmpl.length

          # Match close block token
          closing = tokenizer.exec(template)
          pos = tokenizer.lastIndex

          if echoMode
            result += token[0] + tmpl + closing[0]
          else
            section = match[1]
            [contents, wrapperAttrs] = rule.contents(tmpl, model, section, options)

            if htagPos is -1
              tag = options[rule.wrapper]

              if section isnt lastSectionTag
                lastSectionHTagPos = result.length
                result += injectAttributes(
                  injectTagBinding(&quot;&lt;#{ tag }&gt;#{ contents }&lt;/#{ tag }&gt;&quot;, bindingToken),
                  wrapperAttrs
                )
              else
                result = (
                  result.slice(0, lastSectionHTagPos) +
                  injectAttributes(
                    injectTagBinding(result.slice(lastSectionHTagPos), bindingToken),
                    wrapperAttrs,
                    contents.trim()
                  )
                )

            else
              result = (
                result.slice(0, htagPos) + 
                injectAttributes(
                  injectTagBinding(result.slice(htagPos), bindingToken),
                  wrapperAttrs
                ) +
                contents.trim()
              )
              lastSectionHTagPos = htagPos

            lastSectionTag = rule.lastTag?(model, section) or null


        # Match was found, skip other rules
        break

  result += template.slice(pos)

  # Return accumulated output
  if options.asArrayItem

    # enclose in defaultSectionItem HTML tag if needed
    if isValidHTMLTag(result)
      result 
    else
      tag = options.defaultSectionItem
      &quot;&lt;#{ tag }&gt;#{ result }&lt;/#{ tag }&gt;&quot;

  else
    result</code></pre>
<h3 id="compiling-stage-supporting-utilities">Compiling stage supporting utilities</h3>
<p>String addTagBinding(String, String)</p>
<p>Inject token in HTML element data-jt attribute.
Create attribute if not existent.
wrapperAttrs is array of pairs [attribute, value] to inject in element</p>
<pre><code>injectTagBinding = (template, token) -&gt;
  # group 1: &#39;data-jt&#39; inject position
  # group 2: token inject position, if attribute exists
  # group 3 (RE_DATA_JT): existing &#39;data-jt&#39; value
  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER }) (#{ RE_ANYTHING }) #{ RE_DATA_JT }&quot;).exec(template)
  attrLen = (match[3] or &#39;&#39;).length
  pos = match[1].length + match[2].length + attrLen
  # inject, return result
  ( template.slice(0, pos) +
    ( if attrLen
        (if match[3].trim() is &#39;data-jt=&quot;&#39; then &#39;&#39; else &#39; &#39;) + token
      else
        &#39; data-jt=&quot;&#39; + token + &#39;&quot;&#39;
    ) +
    template.slice(pos)
  )

injectAttributes = (template, attributes, contents) -&gt;
  if not attributes.length then return template

  match = regexp(&quot;^ (#{ RE_SPACE } &lt; #{ RE_IDENTIFIER } #{ RE_ANYTHING })&gt;&quot;).exec(template)
  pos = match[1].length
  (
    template.slice(0, pos) + 
    [&quot; #{ pair[0] }=\&quot;#{ pair[1].replace(/&quot;/g, &#39;&amp;quot;&#39;).replace(/&gt;/g, &#39;&amp;gt;&#39;).replace(/&lt;/g, &#39;&amp;lt;&#39;) }\&quot;&quot; for pair in attributes].join(&#39;&#39;) +
    &#39;&gt;&#39; +
    (contents or &#39;&#39;) +
    template.slice(pos + 1)
  )</code></pre>
<p>Int lastOpenedHTMLTag(String)</p>
<p>Return index of the last opening, maybe opened (no close bracket), HTML tag
followed by end of string, or -1, if no such exists</p>
<pre><code>lastOpenedHTMLTag = (template) -&gt;
  template.trimRight().search(regexp(&quot;&lt; #{ RE_IDENTIFIER } [^&gt;]*? &gt;?$&quot;))</code></pre>
<p>Boolean isValidHTMLTag(String)</p>
<p>Check if contents is properly formatted closed HTML tag</p>
<pre><code>isValidHTMLTag = (contents) -&gt;
  !!contents.trim().match(regexp(&quot;^&lt;(#{ RE_IDENTIFIER }) #{ RE_SPACE }
    [^&gt;]*? &gt; #{ RE_ANYTHING } &lt;/\\1&gt;$ | &lt; [^&gt;]*? /&gt;$&quot;)
  )</code></pre>
<h2 id="bind-rules-processor">Bind rules processor</h2>
<p>void <code>bind</code> (DOMElement root, AnyType model)</p>
<p>Walk DOM and setup reactors on model and nodes.</p>
<pre><code>jtmpl.bind = (node, model, options) -&gt;

  if data_jt = node.getAttribute(&#39;data-jt&#39;)

    for jt in data_jt.trim().split(&#39; &#39;)

      for rule in jtmpl.bindRules

        if match = regexp(rule.pattern).exec(jt)

          console.log(match[0])
          # console.log(model)

          reactor = rule.react([node].concat(match.slice(1), [model, options])...)
          prop = rule.bindTo?(match.slice(1)...)
          # console.log(prop)
          # console.log(reactor)
          propChange(model, prop, reactor)

          recurseContext = rule.recurseContext?(match.slice(1).concat([model])...)

          break

  if recurseContext isnt null
    for child in node.children
      jtmpl.bind(child, recurseContext or model, options)</code></pre>
<h2 id="supporting-code">Supporting code</h2>
<h3 id="useful-shortcut">Useful shortcut</h3>
<pre><code>ap = Array.prototype</code></pre>
<h3 id="regular-expression-utilities">Regular expression utilities</h3>
<p>String escapeRE(String s)</p>
<p>Escape regular expression characters</p>
<pre><code>escapeRE = (s) -&gt; (s + &#39;&#39;).replace(/([.?*+^$[\]\\(){}|-])/g, &#39;\\$1&#39;)</code></pre>
<p>RegExp regexp(String src, Object options)</p>
<p>Replace mustaches with given delimiters, strip whitespace, return RegExp</p>
<pre><code>regexp = (src, delimiters) -&gt;
  # strip whitespace
  src = src.replace(/\s+/g, &#39;&#39;)
  new RegExp((if delimiters then src
    .replace(&#39;{{&#39;,  escapeRE(delimiters[0]))
    .replace(&#39;}}&#39;,  escapeRE(delimiters[1]))
    else src)
  , &#39;g&#39;)</code></pre>
<h3 id="string-utilities">String utilities</h3>
<p>String escapeHTML(String val)</p>
<p>Replace HTML special characters</p>
<pre><code>escapeHTML = (val) -&gt;
  (val? and val or &#39;&#39;)
    .toString()
    .replace /[&amp;&quot;&lt;&gt;\\]/g, (s) -&gt; { 
        &#39;&amp;&#39;: &#39;&amp;amp;&#39;
        &#39;\\&#39;: &#39;\\\\&#39;
        &#39;&quot;&#39;: &#39;\&quot;&#39;
        &#39;&lt;&#39;: &#39;&amp;lt;&#39;
        &#39;&gt;&#39;: &#39;&amp;gt;&#39;
      }[s]</code></pre>
<p>String multiReplace(String template, Array from, Array to)</p>
<p>Replace <code>from</code> literal strings with <code>to</code> strings in template</p>
<pre><code>multiReplace = (template, from, to) -&gt;
  for find, i in from
    template = template.replace(regexp(escapeRE(find)), to[i])
  template</code></pre>
<h3 id="dom-utilities">DOM utilities</h3>
<p>DOMElement createSectionItem (DOMElement parent, AnyType context)</p>
<pre><code>jtmpl.createSectionItem = createSectionItem = (parent, context, options) -&gt;
  element = document.createElement(&#39;body&#39;)
  element.innerHTML = jtmpl(
    multiReplace(parent.getAttribute(&#39;data-jt-1&#39;) or &#39;&#39;,
      options.compiledDelimiters, options.delimiters),
    context
  )
  element = element.children[0]
  if typeof context is &#39;object&#39;
    jtmpl(element, element.innerHTML, context, options)
  element

jtmpl.hasClass = hasClass = (el, name) -&gt; new RegExp(&quot;(\\s|^)#{ name }(\\s|$)&quot;).test(el.className)

jtmpl.addClass = addClass = (el, name) -&gt; 
  if not hasClass(el, name) then el.className += (el.className and &#39; &#39; or &#39;&#39;) + name

jtmpl.removeClass = removeClass = (el, name) -&gt;
  if hasClass(el, name) then el.className = el.className
    .replace(new RegExp(&quot;(\\s|^)#{name}(\\s|$)&quot;), &#39;&#39;)
    .replace(/^\s+|\s+$/g, &#39;&#39;)</code></pre>
<h3 id="binding-utilities">Binding utilities</h3>
<p>void propChange(Object obj, String prop, Function callback)</p>
<p>Register a callback to handle object property change. </p>
<pre><code>propChange = (obj, prop, callback) -&gt;
  # All must be specified, don&#39;t fail if not
  if not (obj and prop and callback) then return

  oldDescriptor = (Object.getOwnPropertyDescriptor(obj, prop) or
    Object.getOwnPropertyDescriptor(obj.constructor.prototype, prop))

  Object.defineProperty(obj, prop, {
    get: oldDescriptor.get or -&gt; oldDescriptor.value,
    set: ((val) -&gt;
      oldDescriptor.set?(val) or oldDescriptor.value = val
      callback(val)
    ),
    configurable: true
  })</code></pre>
<p>void bindArrayToNodeChildren(Array array, DOMElement node)</p>
<p>Bind an array to DOM node, 
so when array is modified, node children are updated accordingly.</p>
<p>Array is augmented by attaching listeners on existing indices
and setting a proxy for each mutable operation. 
<code>createSectionItem</code> is used for creating new items.</p>
<pre><code>jtmpl.bindArrayToNodeChildren = bindArrayToNodeChildren = (array, node, options) -&gt;

  # array already augmented?
  if not array.__garbageCollectNodes

    # it&#39;s possible for a referenced node to be destroyed. free the reference
    array.__garbageCollectNodes = -&gt;
      i = this.__nodes.length
      while --i
        if not this.__nodes[i].parentNode
          this.__nodes.splice(i, 1)

    array.__removeEmpty = -&gt;
      if not this.length then node.innerHTML = &#39;&#39;

    array.__addEmpty = -&gt;
      if not this.length
        node.innerHTML = jtmpl(
          multiReplace(node.getAttribute(&#39;data-jt-0&#39;) or &#39;&#39;,
            options.compiledDelimiters, options.delimiters),
          {}
        )

    # Mutable array operations

    array.pop = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      node.removeChild(node.children[node.children.length - 1]) for node in this.__nodes
      ap.pop.apply(this, arguments)
      ap.pop.apply(this.__values, arguments)
      this.__addEmpty()

    array.push = (item) -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
      ap.push.apply(this, arguments)
      len = this.__values.length
      result = ap.push.apply(this.__values, arguments)
      bindProp(item, len)
      result

    array.reverse = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      result = ap.reverse.apply(this.__values, arguments)
      for node in this.__nodes
        node.innerHTML = &#39;&#39;
        for item, i in this.__values
          node.appendChild(createSectionItem(node, item, options))
          bindProp(item, i)
      this.__addEmpty()
      result

    array.shift = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      ap.shift.apply(this, arguments)
      result = ap.shift.apply(this.__values, arguments)
      for node in this.__nodes
        node.removeChild(node.children[0])
      for item, i in this.__values
        bindProp(item, i)
      this.__addEmpty()
      result

    array.unshift = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      for item in ap.slice.call(arguments).reverse()
        for node in this.__nodes
          node.insertBefore(createSectionItem(node, item, options), node.children[0])
      ap.unshift.apply(this, arguments)
      result = ap.unshift.apply(this.__values, arguments)
      for item, i in this.__values
        bindProp(item, i)
      this.__addEmpty()
      result

    array.sort = -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      ap.sort.apply(this, arguments)
      result = ap.sort.apply(this.__values, arguments)
      for node in this.__nodes
        node.innerHTML = &#39;&#39;
        for item, i in array
          node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
          bindProp(item, i)
      this.__addEmpty()
      result

    array.splice = (index, howMany) -&gt;
      this.__removeEmpty()
      this.__garbageCollectNodes()
      for node in this.__nodes
        for i in [0...howMany]
          node.removeChild(node.children[index])
        for item in ap.slice.call(arguments, 2)
          node.insertBefore(createSectionItem(node, item, options), node.children[index])
          bindProp(item, index)
      ap.splice.apply(this, arguments)
      ap.splice.apply(this.__values, arguments)
      this.__addEmpty()

    # Bind property
    bindProp = (item, i) -&gt;
      array.__values[i] = item
      Object.defineProperty(array, i, 
        get: -&gt; this.__values[i]
        set: (val) -&gt; 
          this.__garbageCollectNodes()
          this.__values[i] = val
          node.replaceChild(createSectionItem(node, val, options), node.children[i]) for node in this.__nodes
      )

    # bound nodes
    Object.defineProperty(array, &#39;__nodes&#39;,
      enumerable: false
      writable: true
      value: []
    )
    # onchange handlers for each item
    Object.defineProperty(array, &#39;__values&#39;,
      enumerable: false
      writable: true
      value: []
    )
    for item, i in array
      bindProp(item, i)

  if array.__nodes.indexOf(node) is -1 then array.__nodes.push(node)
  array</code></pre>

          <footer>
              <span>{&rsaquo;</span> Copyright &copy; 2013 Atanas Minev, <a href="LICENSE">MIT license</a>
          </footer>
        </div>
        <script src="/js/highlight.min.js"></script>
        <script src="/js/highlight-coffee.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-43285803-1', 'jtmpl.com');
          ga('send', 'pageview');
        </script>
    </body>
</html>