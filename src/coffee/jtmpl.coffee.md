## Introduction

jtmpl is written in [Literate CoffeeScript](http://ashkenas.com/literate-coffeescript/).
Production version is generated by extracting the code, compiling and minifying it via UglifyJS.

This documentation is currently a draft.





## Interface



#### Compile template 

_(NodeJS and browser)_

jtmpl(String template, AnyType model)

`jtmpl('Hello, {{who}}', { who: 'world' }) # "Hello, <span data-jt="who"></span>"`
`jtmpl('#template-id', { who: 'world' })   # Browser only



#### Bind

Bind model to DOM node using data-jt attributes

_(browser only)_

jtmpl(DOMElement target, Object model)



#### Compile (if needed) and bind 

_(browser only)_

jtmpl(DOMElement target, String template, AnyType model)

`jtmpl('#target', 'Hello, {{who}}', model)`

`jtmpl('#target', '#template-id', model)`

`jtmpl('#target', '#target', model) # target.innerHTML will be used as template`



#### Requests

_(currently browser only)_

Only GET and POST currently supported.

jtmpl(String method, String url [, Object params] [, Function callback])

`jtmpl('GET', 'api/endpoint/42') # fire and forget`

`jtmpl('GET', 'api/endpoint/42', function (response) { alert(response) })`

If response is valid JSON, it's automatically parsed

`jtmpl('POST', 'api/endpoint', { id: 42, answer: 42 }, function (err, resp) { ... })`



Main function

Export for NodeJS and browser

A big `if..else if` statement as arguments pattern matcher

    jtmpl = (exports ? this).jtmpl = (target, template, model, options) ->

      args = [].slice.call(arguments)

      # Deprecated. `jtmpl(selector)`?
      if args.length is 1 and typeof args[0] is 'string'
        [].slice.call(document.querySelectorAll(args[0]))

      # `jtmpl('HTTP_METHOD', url[, parameters[, callback[, options]]])`?
      else if args[0] in ['GET', 'POST']
        xhr = new XMLHttpRequest()
        callback = args.reduce(
          (prev, curr) -> typeof curr is 'function' and curr or prev,
          null
        )
        opts = args[args.length - 1]
        if typeof opts isnt 'object' then opts = {}
        for prop in Object.getOwnPropertyNames(opts)
          xhr[prop] = opts[prop]
        request = if typeof args[2] is 'string' then args[2] else if typeof args[2] is 'object' then JSON.stringify(args[2]) else ''
        xhr.onload = (event) ->
          if callback
            callback.call(this, this.responseText, event)
        xhr.open(args[0], args[1], opts.async or true, opts.user, opts.password)
        xhr.send(request)

      # `jtmpl(template, model[, options])`?
      else if typeof args[0] is 'string' and (typeof args[1] isnt 'string' or args.length is 2) and args[1] isnt null and args.length in [2, 3]
        template = '' + (args[0].match(RE_NODE_ID) and document.querySelector(args[0]).innerHTML or args[0])
        opts = jtmpl.options(args[2], args[1])

        ## Preprocess template
        for rule in jtmpl.preprocessingRules
          template = template.replace(regexp(rule[0], opts.delimiters), rule[1])

        jtmpl.compile(template, args[1], null, false, opts).trim()

      # `jtmpl(target, model[, options])`?
      else if typeof args[0].cloneNode is 'function' and typeof args[1] is 'object'
        # Bind recursively using data-jt attributes
        jtmpl.bind(args[0], args[1], jtmpl.options(args[2], args[1]))

        # Post-binding stage
        jtmpl.postbind(args[1])

      # `jtmpl(target, template, model[, options])`
      else
        target = typeof args[0].cloneNode is 'function' and args[0] or document.querySelector(args[0])
        template = args[1].match(RE_NODE_ID) and document.querySelector(args[1]).innerHTML or args[1]
        model = args[2]
        opts = jtmpl.options(args[3], args[2])

        if target.nodeName is 'SCRIPT'
          newTarget = document.createElement(opts.defaultTargetTag)
          newTarget.id = target.id
          target.parentNode.replaceChild(newTarget, target)
          target = newTarget

        html = jtmpl(template, model, opts)
        if target.innerHTML isnt html then target.innerHTML = html

        jtmpl(target, model, opts)



Default options

    jtmpl.defaultOptions = {
      
      delimiters: '{{ }}'

      compiledDelimiters: '#{ }#'

      defaultSection: 'div'

      defaultSectionItem: 'div'

      defaultVar: 'span'

      defaultTargetTag: 'div'
    }


Construct options object by merging default and specified options    

    jtmpl.options = (options, rootModel) ->
      options = options or {}
      opts = JSON.parse(JSON.stringify(jtmpl.defaultOptions))
      for prop of Object.getOwnPropertyNames(options)
        opts[prop] = options[prop]
      # if typeof options.delimiters is 'string'
      opts.delimiters = opts.delimiters.split(' ')
      # if typeof options.compiledDelimiters is 'string'
      opts.compiledDelimiters = opts.compiledDelimiters.split(' ')
      opts.rootModel = if options.rootModel then options.rootModel else rootModel
      opts





## Rules

jtmpl is a processor of rules. 

Rules in sequences are in increasing generality order. It's just like 
[Haskell pattern matching](http://learnyouahaskell.com/syntax-in-functions).

Compilation and binding stages can be extended with new rules,
put them at the beginning:

`jtmpl.compileRules.unshift({ new compile rule... })`  
`jtmpl.bindRules.unshift({ new binding rule... })`





### Regular expression atoms

Used in various matchers

    RE_IDENTIFIER = '[\\w\\.\\-]+'
    RE_NODE_ID = '^#[\\w\\.\\-]+$'
    RE_ANYTHING = '[\\s\\S]*?'
    RE_SPACE = '\\s*'
    RE_PIPE = "(?: \\| (#{ RE_IDENTIFIER }) )?"
    RE_DATA_JT = '(?: ( \\s* data-jt = " [^"]* )" )?'
    RE_COLLECTION_TEMPLATE = /^(#|\^)\s([\s\S]*)$/




### Pre-processing rules

Transformations to clean up template for easier matching

    jtmpl.preprocessingRules = [
      # Convert triple mustache (output unescaped var) to alt form
      ["({{) { (#{ RE_IDENTIFIER }) } (}})", '$1&$2$3']

      # Strip HTML comments that enclose tokens
      ["<!-- #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } -->", '$1']

      # Strip single quotes around html element attributes associated with tokens
      ["(#{ RE_IDENTIFIER })='({{ #{ RE_IDENTIFIER } }})'", '$1=$2']

      # Strip double quotes around html element attributes associated with tags
      ["(#{ RE_IDENTIFIER })=\"({{ #{ RE_IDENTIFIER } }})\"", '$1=$2']

      # If tags stand on their own line remove the line, keep the tag only
      ["\\n #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } \\n", '\n$1\n']
    ]




### Formatters and mappings

None provided by default, put yours like `jtmpl.formatters.myFormatter = function (val) {...}`

    jtmpl.formatters = {}    
    jtmpl.mappings = {}    




### Compile rules 

Delimiters in `pattern`s are replaced with escaped options.delimiters, whitespace - stripped.

Inline tags implement `replaceWith`, section (block) tags implement `contents`.

Signatures:

[String, Array] `replaceWith` (String for each group in pattern, AnyType model)

String `bindingToken` (String for each group in pattern)

[String, Array] `contents` (String template, AnyType model, String section, Object options)



    jtmpl.compileRules = [




#### `<tag class="{{class-name}} other-classes">`

`model['class-name']` is expected to be boolean

      {
        pattern: "(class=\"? [\\w \\. \\- \\s {{}}]*) {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: (pre, prop, model) ->
          val = getValue(model, prop)
          [ # Emit match, and class name if booleanVar
            (pre.search('{') is -1 and pre or ' ') +
            (typeof val is 'boolean' and val and prop or '')
            ,
            []
          ]

        echoReplaceWith: (pre, prop) ->
          if pre.search('{') > - 1 then " {{#{ prop }}}" else null

        bindingToken: (pre, prop) -> "class=#{ prop }"
      }



#### `<tag onevent="{{handler}}">`

`on`-prefixed properties are event handlers.
`handler` is expected to be a function,
`handler`'s `this` is the context in which the handler has been attached.
No need to add `onchange` handlers, syncing of DOM element values and `model` is already handled.

      {
        pattern: "on(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: -> ['', []]

        bindingToken: (event, handler) -> "on#{ event }=#{ handler }"
      }



#### `<tag attr="{{prop}}"`

When `prop` is null property is absent, otherwise equals `prop`.

When `prop` is boolean, value determines presense of attribute.

      {
        pattern: "(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: (attr, prop, model) ->
          val = getValue(model, prop)
          # null?
          if not val? or val is null
            ['', []]
          # boolean?
          else if typeof val is 'boolean'
            [(if val then attr else ''), []]
          # quoted value
          else
            ["#{ attr }=\"#{ val }\"", []]

        bindingToken: (attr, prop) -> "#{ attr }=#{ prop }"
      }



#### `{{^inverted_section}}`

      {
        pattern: "{{ \\^ (#{ RE_IDENTIFIER }) }}$"

        wrapper: 'defaultSection'

        lastTag: (model, section) ->
          if Array.isArray(model[section]) then section else null

        contents: (template, model, section, options) ->
          val = getValue(model, section)

          # Sequence?
          if Array.isArray(val)
            [
              # Render body if array empty
              if not val.length then jtmpl(template, model) else ''
              ,
              [
                [ # template as node data attribute
                  'data-jt-0',

                  multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
                ]
              ]
            ]

          else
            [ jtmpl(template, model),
              if val then [['style', 'display:none']] else []
            ]

        bindingToken: (section) -> "^#{ section }"
      }

      

#### `{{#section}}`

      {
        pattern: "{{ \\# (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$"

        lastTag: (model, section) ->
          if Array.isArray(model[section]) then section else null

        wrapper: 'defaultSection'

        contents: (template, model, section, mapping, options) ->
          val = getValue(model, section)
          # Sequence?
          if Array.isArray(val)
            mapping = options.rootModel[mapping] or model[mapping] or jtmpl.mappings[mapping]
            if typeof mapping is 'function'
              val = val.map(mapping).filter((x) -> x isnt null and x isnt undefined)

            [ # Render body for each item
              (jtmpl(template, item, { asArrayItem: true }) for item in val).join(''),
              [ # template as node data attribute
                [
                  'data-jt-1',

                  multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
                ]
              ]
            ]

          # Context?
          else if typeof val is 'object'
            # Render body using context
            [ jtmpl(template, val),
              []
            ]

          else
            [ jtmpl(template, model),
              if not val then [['style', 'display:none']] else []
            ]

        bindingToken: (section) -> "##{ section }"
      }



#### `{{&unescaped_var}}`

      {
        pattern: "{{ & (#{ RE_IDENTIFIER }) }}$"

        wrapper: 'defaultVar'

        replaceWith: (prop, model) -> [getValue(model, prop), []]

        bindingToken: (prop) -> prop
      }



#### `{{var}}`

      {
        pattern: "{{ (#{ RE_IDENTIFIER }) #{ RE_PIPE } }}$"

        wrapper: 'defaultVar'

        replaceWith: (prop, formatter, model) -> [escapeHTML(getValue(model, prop, undefined, undefined, model[formatter] || jtmpl.formatters?[formatter] || null)), []]

        bindingToken: (prop, formatter) -> prop + (if formatter then '|' + formatter else '')
      }

    ]





### Bind rules

Matching is done on tokenized data-jt items

`react` signature:

Function void (AnyType val) `react`
(DOMElement node, String for each pattern group, AnyType model, Object options)

    jtmpl.bindRules = [




#### `value/checked/selected=var`

      {
        pattern: "(value | checked | selected) = (#{ RE_IDENTIFIER })"

        bindTo: (attr, prop) -> prop,

        react: (node, attr, prop, model) ->
          # attach DOM reactor

          # select option?
          if node.nodeName is 'OPTION'
            node.parentNode.addEventListener('change', ->
              if model[prop] isnt node.selected then model[prop] = node.selected
            )

          # radio group?
          if node.type is 'radio' and node.name
            node.addEventListener('change', ->
              if node[attr]
                for input in document.querySelectorAll("input[type=radio][name=#{ node.name }]")
                  if input isnt node
                    input.dispatchEvent(new Event('change'))
              model[prop] = node[attr]
            )

          # text input?
          if node.type is 'text'
            node.addEventListener('input', -> model[prop] = node[attr])

          # other inputs
          else
            node.addEventListener('change', -> model[prop] = node[attr])

          reaction = (val) ->
            val = getValue(model, prop, true, reactor)
            if val is undefined then return

            if node[attr] isnt val then node[attr] = val

          reactor = (val) ->
            if val isnt undefined then reaction(val)

          if typeof model[prop] is 'function' then reactor(getValue(model, prop, true, reaction))

          reactor
      }



#### onevent=var

      {
        pattern: "on(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })"

        react: (node, evnt, listener, model, options) ->
          handler = options?.rootModel?[listener] or model[listener]
          if typeof handler is 'function'
            node.addEventListener(evnt, handler.bind(model))
          else
            throw ":( #{ listener } is not a function, cannot attach event handler"

          # job done, no reactor to return
          null
      }




#### class=var

      {
        pattern: "class = (#{ RE_IDENTIFIER })"

        bindTo: (prop) -> prop

        react: (node, prop, model) ->
          reaction = (val) ->
            (val and addClass or removeClass)(node, prop)

          reactor = (val) ->
            if val isnt undefined then reaction(val)

          if typeof model[prop] is 'function' then reactor(getValue(model, prop, true, reaction))

          reactor
      }




#### attr=var

      {
        pattern: "(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })"

        bindTo: (attr, prop) -> prop

        react: (node, attr, prop, model) ->
          reaction = (val) ->
            if node[attr] isnt val then node[attr] = val

          reactor = (val) ->
            if val isnt undefined then reaction(val)

          if typeof model[prop] is 'function' then reactor(getValue(model, prop, true, reaction))

          reactor
      }




#### section

      {
        pattern: "(# | \\^) (#{ RE_IDENTIFIER })"

        bindTo: (sectionType, prop) -> prop

        # context for recursion
        recurseContext: (sectionType, attr, model) ->
          val = model[attr]
          if Array.isArray(val)
            null
          else if typeof val is 'object'
            val
          else
            model

        react: (node, sectionType, attr, model, options) ->
          val = model[attr]

          if Array.isArray(val) and sectionType is '#'
            jtmpl.bindArrayToNodeChildren(val, node, options)
            # bind collection items to node children
            for child, i in node.children
              if typeof val[i] is 'object'
                jtmpl.bind(child, val[i], options)

          reaction = (val) ->
            # collection?
            if Array.isArray(val)
              jtmpl.bindArrayToNodeChildren(val, node, options)

              node.innerHTML =
                if not val.length
                  jtmpl(
                    multiReplace(node.getAttribute('data-jt-0') or '',
                      options.compiledDelimiters, options.delimiters),
                    {}
                  )
                else 
                  ''

              node.appendChild(jtmpl.createSectionItem(node, item, options)) for item in val

            # local context?
            else if typeof val is 'object'
              node.innerHTML = jtmpl(
                multiReplace(node.getAttribute('data-jt-1') or '',
                    options.compiledDelimiters, options.delimiters),
                val
              )
              jtmpl(node, node.innerHTML, val, { rootModel: model })

            # if section
            else
              node.style.display = (!val isnt (sectionType is '^')) and 'none' or ''

          reactor = (val) ->
            if val isnt undefined then reaction(val)

          if typeof model[attr] is 'function' then reactor(getValue(model, attr, true, reaction))

          reactor
      }




#### var

      {
        pattern: "(#{ RE_IDENTIFIER }) #{ RE_PIPE }"

        bindTo: (prop) -> prop

        react: (node, prop, formatter, model, options) ->
          reaction = (val) ->
            node.innerHTML = (options.rootModel?[formatter] or model[formatter] or jtmpl.formatters?[formatter] or ((x) -> x))(val)
            if typeof val is 'object' then jtmpl.bind(node, model, options)

          reactor = (val) ->
            if val isnt undefined then reaction(val)

          if typeof model[prop] is 'function' then reactor(getValue(model, prop, true, reaction, formatter))

          reactor
      }



    ]





## Compile rules processor

### Compile routine

Tokenize template and apply each rule on tokens.
Rules can be inline or recursive, end block is hardcoded as "{{/block}}".
Current delimiters are respected.

String  template
AnyType model
String  openTag
Boolean echoMode
Array   delimiters
Boolean asArrayItem


    jtmpl.compile = (template, model, openTag, echoMode, options, asArrayItem) ->

      tokenizer = regexp("{{ (\/?) (#{ RE_ANYTHING }) }}", options.delimiters)
      result = ''
      pos = 0

      while (token = tokenizer.exec(template))

        # End block?
        if token[1]
          if token[2] isnt openTag
            throw new Error(openTag and
              ":( expected {{/#{ openTag }}}, got {{#{ token[2] }}}" or
              ":( unexpected {{/#{ token[2] }}}")
              
          # Exit recursion
          return result + template.slice(pos, tokenizer.lastIndex - token[0].length)

        slice = template.slice(Math.max(0, pos - 128), tokenizer.lastIndex)

        # Process rules
        for rule in jtmpl.compileRules

          match = regexp(rule.pattern, options.delimiters).exec(slice)
          if match
            # accumulate output
            result += template.slice(pos, tokenizer.lastIndex - match[0].length)

            # inject token in data-jt attr
            htagPos = lastOpenedHTMLTag(result)
            bindingToken = rule.bindingToken(match.slice(1)...)

            # inline tag or section?
            if rule.replaceWith?
              if echoMode
                result += rule.echoReplaceWith?(match.slice(1)...) or match[0]
              else
                [replaceWith, wrapperAttrs] =
                  rule.replaceWith(match.slice(1).concat([model])...)

                if htagPos is -1 and rule.wrapper?
                  # wrapping needed
                  tag = options[rule.wrapper]
                  result += injectAttributes(
                    injectTagBinding("<#{ tag }>#{ replaceWith }</#{ tag }>", bindingToken),
                    wrapperAttrs
                  )
                else
                  result += replaceWith
                  result = result.slice(0, htagPos) + injectAttributes(
                    injectTagBinding(result.slice(htagPos), bindingToken),
                    wrapperAttrs
                  )

              pos = tokenizer.lastIndex

            else
              # Recursively get nested template (echoMode=on)
              tmpl = jtmpl.compile(
                template.slice(tokenizer.lastIndex), 
                model, match[1], true, options)

              # Skip block contents
              tokenizer.lastIndex += tmpl.length

              # Match close block token
              closing = tokenizer.exec(template)
              pos = tokenizer.lastIndex

              if echoMode
                result += token[0] + tmpl + closing[0]
              else
                section = match[1]
                args = [tmpl, model].concat(match.slice(1)).concat([options])
                [contents, wrapperAttrs] = rule.contents(args...)

                if htagPos is -1
                  tag = options[rule.wrapper]

                  if section isnt lastSectionTag
                    lastSectionHTagPos = result.length
                    result += injectAttributes(
                      injectTagBinding("<#{ tag }>#{ contents }</#{ tag }>", bindingToken),
                      wrapperAttrs
                    )
                  else
                    result = (
                      result.slice(0, lastSectionHTagPos) +
                      injectAttributes(
                        injectTagBinding(result.slice(lastSectionHTagPos), bindingToken),
                        wrapperAttrs,
                        contents.trim()
                      )
                    )

                else
                  result = (
                    result.slice(0, htagPos) + 
                    injectAttributes(
                      injectTagBinding(result.slice(htagPos), bindingToken),
                      wrapperAttrs
                    ) +
                    contents.trim()
                  )
                  lastSectionHTagPos = htagPos

                lastSectionTag = rule.lastTag?(model, section) or null


            # Match was found, skip other rules
            break

      result += template.slice(pos)

      # Return accumulated output
      if options.asArrayItem

        # enclose in defaultSectionItem HTML tag if needed
        if isValidHTMLTag(result)
          result 
        else
          tag = options.defaultSectionItem
          "<#{ tag }>#{ result }</#{ tag }>"

      else
        result




### Compiling stage supporting utilities

String addTagBinding(String, String)

Inject token in HTML element data-jt attribute.
Create attribute if not existent.
wrapperAttrs is array of pairs [attribute, value] to inject in element

    injectTagBinding = (template, token) ->
      # group 1: 'data-jt' inject position
      # group 2: token inject position, if attribute exists
      # group 3 (RE_DATA_JT): existing 'data-jt' value
      match = regexp("^ (#{ RE_SPACE } < #{ RE_IDENTIFIER }) (#{ RE_ANYTHING }) #{ RE_DATA_JT }").exec(template)
      attrLen = (match[3] or '').length
      pos = match[1].length + match[2].length + attrLen
      # inject, return result
      ( template.slice(0, pos) +
        ( if attrLen
            (if match[3].trim() is 'data-jt="' then '' else ' ') + token
          else
            ' data-jt="' + token + '"'
        ) +
        template.slice(pos)
      )

    injectAttributes = (template, attributes, contents) ->
      if not attributes.length then return template

      match = regexp("^ (#{ RE_SPACE } < #{ RE_IDENTIFIER } #{ RE_ANYTHING })>").exec(template)
      pos = match[1].length
      (
        template.slice(0, pos) + 
        [" #{ pair[0] }=\"#{ pair[1].replace(/"/g, '&quot;').replace(/>/g, '&gt;').replace(/</g, '&lt;') }\"" for pair in attributes].join('') +
        '>' +
        (contents or '') +
        template.slice(pos + 1)
      )



Int lastOpenedHTMLTag(String)

Return index of the last opening, maybe opened (no close bracket), HTML tag
followed by end of string, or -1, if no such exists

    lastOpenedHTMLTag = (template) ->
      template.trimRight().search(regexp("< #{ RE_IDENTIFIER } [^>]*? >?$"))



Boolean isValidHTMLTag(String)

Check if contents is properly formatted closed HTML tag

    isValidHTMLTag = (contents) ->
      !!contents.trim().match(regexp("^<(#{ RE_IDENTIFIER }) #{ RE_SPACE }
        [^>]*? > #{ RE_ANYTHING } </\\1>$ | < [^>]*? />$")
      )





## Post-binding stage

Init function (`model['#']`) and routes via window onhashchange are processed here.

If route definition contains a '(', then it's considered regular expression
and groups are passed as parameters to the route handler.

Example routes:

`'#simple-route': function () { ...`

`'#page-(\\d+)': function (pageNumber) { ...`

    jtmpl.postbind = (model) ->
      if typeof model['#'] is 'function'
        model['#'].apply(model)

      props = Object.getOwnPropertyNames(model)
      routes = props.filter((prop) -> regexp("##{ RE_ANYTHING }").exec(prop))

      if routes.length and window
        hashchange = -> 
          for route in routes
            if '(' in route
              match = new RegExp(route, 'g').exec(window.location.hash)
              if match and typeof model[route] is 'function'
                model[route].apply(model, match.slice(1))
            else
              if route is window.location.hash and typeof model[route] is 'function'
                model[route].apply(model)

        hashchange()

        window.addEventListener('hashchange', hashchange)




## Bind rules processor

void `bind` (DOMElement root, AnyType model)

Walk DOM and setup reactors on model and nodes.


    jtmpl.bind = (node, model, options) ->

      if data_jt = node.getAttribute('data-jt')

        for jt in data_jt.trim().split(' ')

          for rule in jtmpl.bindRules

            if match = regexp(rule.pattern).exec(jt)

              reactor = rule.react([node].concat(match.slice(1), [model, options])...)
              prop = rule.bindTo?(match.slice(1)...)
              if model[prop] is undefined then model[prop] = null
              propChange(model, prop, reactor)

              recurseContext = rule.recurseContext?(match.slice(1).concat([model])...)

              break

      if recurseContext isnt null
        for child in node.children
          jtmpl.bind(child, recurseContext or model, options)





## Supporting code





### Regular expression utilities

String escapeRE(String s)

Escape regular expression characters

    escapeRE = (s) -> (s + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1')




RegExp regexp(String src, Object options)

Replace mustaches with given delimiters, strip whitespace, return RegExp

    regexp = (src, delimiters) ->
      # strip whitespace
      src = src.replace(/\s+/g, '')
      new RegExp((if delimiters then src
        .replace('{{',  escapeRE(delimiters[0]))
        .replace('}}',  escapeRE(delimiters[1]))
        else src)
      , 'g')




AnyType getValue(AnyType model, String prop[, Function callback[, Function self]])

Get value of `model[prop]`, evaluate value function if computed value

When `model[prop]` is function, it should use `this` to refer to model properties,
like `this('foo')` or even `@ 'foo'` in CoffeeScript. 

When in `trackDependencies` mode:

value function can compute the result asynchronously,
return undefined to signal this, finally call `callback` with computed value on success.

`model.__dependents[prop]` registers all descendents for a `prop`

    getValue = (model, prop, trackDependencies, callback, formatter) ->
      formatter = formatter or (x) -> x

      getter = (prop) ->
        result = model[prop]
        formatter(
          if typeof result is 'function'
            result.call(getter)
          else
            result
        )

      dependencyTracker = (propToReturn) ->
        model.__dependents[propToReturn] ?= []
        if model.__dependents[propToReturn].indexOf(prop) is -1
          model.__dependents[propToReturn].push(prop)
        getter(propToReturn)

      if prop is '.' then return formatter(model)

      val = model[prop]
      if typeof val is 'function'
        val.call(
          # `this` function
          if trackDependencies 
            model.__dependents ?= {}
            dependencyTracker
          else
            getter
          ,
          callback
        )
      else
        formatter(val)




### String utilities

String escapeHTML(String val)

Replace HTML special characters

    escapeHTML = (val) ->
      (val? and val or '')
        .toString()
        .replace /[&"<>\\]/g, (s) -> { 
            '&': '&amp;'
            '\\': '\\\\'
            '"': '\"'
            '<': '&lt;'
            '>': '&gt;'
          }[s]




String multiReplace(String template, Array from, Array to)

Replace `from` literal strings with `to` strings in template

    multiReplace = (template, from, to) ->
      for find, i in from
        template = template.replace(regexp(escapeRE(find)), to[i])
      template






### DOM utilities

DOMElement createSectionItem (DOMElement parent, AnyType context)

    jtmpl.createSectionItem = createSectionItem = (parent, context, options) ->
      if context is undefined then context = {}
      element = document.createElement('body')
      element.innerHTML = jtmpl(
        multiReplace(parent.getAttribute('data-jt-1') or '',
          options.compiledDelimiters, options.delimiters),
        context
      )
      element = element.children[0]
      if typeof context is 'object'
        jtmpl(element, element.innerHTML, context, options)
      element

    jtmpl.hasClass = hasClass = (el, name) -> new RegExp("(\\s|^)#{ name }(\\s|$)").test(el.className)

    jtmpl.addClass = addClass = (el, name) -> 
      if not hasClass(el, name) then el.className += (el.className and ' ' or '') + name

    jtmpl.removeClass = removeClass = (el, name) ->
      if hasClass(el, name) then el.className = el.className
        .replace(new RegExp("(\\s|^)#{name}(\\s|$)"), '')
        .replace(/^\s+|\s+$/g, '')




### Binding utilities

void propChange(Object obj, String prop, Function callback)

Register a callback to handle object property change. 

    propChange = (obj, prop, callback) ->
      # All must be specified, don't fail if not
      if not (obj and prop and callback) then return

      oldDescriptor = (Object.getOwnPropertyDescriptor(obj, prop) or
        Object.getOwnPropertyDescriptor(obj.constructor.prototype, prop))

      Object.defineProperty(obj, prop, {
        get: oldDescriptor.get or -> oldDescriptor.value,
        set: ((val) ->
          if signal = val?.__signal
            val = getValue(signal.obj, signal.prop, true, callback)
            if val isnt undefined then callback(val)
          else
            oldDescriptor.set?(val) or (
              if typeof oldDescriptor.value is 'function'
                oldDescriptor.value.call(((p, val) -> obj[p] = val), val)
              else
                oldDescriptor.value = val
            )
            callback(val)

          for dependent in obj.__dependents?[prop] or []
            obj[dependent] = {
              __signal: {
                obj: obj,
                prop: dependent
              }
            }

          return
        ),
        configurable: true
      })





void bindArrayToNodeChildren(Array array, DOMElement node)

Bind an array to DOM node, 
so when array is modified, node children are updated accordingly.

Array is augmented by attaching listeners on existing indices
and setting a proxy for each mutable operation. 
`createSectionItem` is used for creating new items.


    jtmpl.bindArrayToNodeChildren = bindArrayToNodeChildren = (array, node, options) ->

      # array already augmented?
      if not array.__garbageCollectNodes

        # it's possible for a referenced node to be destroyed. free the reference
        array.__garbageCollectNodes = ->
          i = this.__nodes.length
          while --i
            if not this.__nodes[i].parentNode
              this.__nodes.splice(i, 1)

        array.__removeEmpty = ->
          if not this.length then node.innerHTML = ''

        array.__addEmpty = ->
          if not this.length
            node.innerHTML = jtmpl(
              multiReplace(node.getAttribute('data-jt-0') or '',
                options.compiledDelimiters, options.delimiters),
              {}
            )

        # Mutable array operations

        array.pop = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          node.removeChild(node.children[node.children.length - 1]) for node in this.__nodes
          [].pop.apply(this, arguments)
          [].pop.apply(this.__values, arguments)
          this.__addEmpty()

        array.push = (item) ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
          [].push.apply(this, arguments)
          len = this.__values.length
          result = [].push.apply(this.__values, arguments)
          bindProp(item, len)
          result

        array.reverse = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          result = [].reverse.apply(this.__values, arguments)
          for node in this.__nodes
            node.innerHTML = ''
            for item, i in this.__values
              node.appendChild(createSectionItem(node, item, options))
              bindProp(item, i)
          this.__addEmpty()
          result

        array.shift = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          [].shift.apply(this, arguments)
          result = [].shift.apply(this.__values, arguments)
          for node in this.__nodes
            node.removeChild(node.children[0])
          for item, i in this.__values
            bindProp(item, i)
          this.__addEmpty()
          result

        array.unshift = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          for item in [].slice.call(arguments).reverse()
            for node in this.__nodes
              node.insertBefore(createSectionItem(node, item, options), node.children[0])
          [].unshift.apply(this, arguments)
          result = [].unshift.apply(this.__values, arguments)
          for item, i in this.__values
            bindProp(item, i)
          this.__addEmpty()
          result

        array.sort = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          [].sort.apply(this, arguments)
          result = [].sort.apply(this.__values, arguments)
          for node in this.__nodes
            node.innerHTML = ''
            for item, i in array
              node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
              bindProp(item, i)
          this.__addEmpty()
          result

        array.splice = (index, howMany) ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          for node in this.__nodes
            for i in [0...howMany]
              node.removeChild(node.children[index])
            for item in [].slice.call(arguments, 2)
              node.insertBefore(createSectionItem(node, item, options), node.children[index])
              bindProp(item, index)
          [].splice.apply(this, arguments)
          [].splice.apply(this.__values, arguments)
          this.__addEmpty()

        # Bind property
        bindProp = (item, i) ->
          array.__values[i] = item
          Object.defineProperty(array, i, 
            get: -> this.__values[i]
            set: (val) -> 
              this.__garbageCollectNodes()
              this.__values[i] = val
              node.replaceChild(createSectionItem(node, val, options), node.children[i]) for node in this.__nodes
          )

        # bound nodes
        Object.defineProperty(array, '__nodes',
          enumerable: false
          writable: true
          value: []
        )
        # onchange handlers for each item
        Object.defineProperty(array, '__values',
          enumerable: false
          writable: true
          value: []
        )
        for item, i in array
          bindProp(item, i)

      if array.__nodes.indexOf(node) is -1 then array.__nodes.push(node)
      array
