## Introduction

jtmpl is written in [Literate CoffeeScript](http://ashkenas.com/literate-coffeescript/).
Production version is generated by extracting the code, compiling and minifying it via UglifyJS.

This documentation is currently a draft.





## Interface



#### Compile template 

_(NodeJS and browser)_

jtmpl(String template, AnyType model)

`jtmpl('Hello, {{who}}', { who: 'world' }) # "Hello, <span data-jt="who"></span>"`
`jtmpl('#template-id', { who: 'world' })   # Browser only



#### Bind

Bind model to DOM node using data-jt attributes

_(browser only)_

jtmpl(DOMElement target, Object model)



#### Compile (if needed) and bind 

_(browser only)_

jtmpl(DOMElement target, String template, AnyType model)

`jtmpl('#target', 'Hello, {{who}}', model)`

`jtmpl('#target', '#template-id', model)`

`jtmpl('#target', '#target', model) # target.innerHTML will be used as template`



#### Requests

_(currently browser only)_

Only GET and POST currently supported.

jtmpl(String method, String url [, Object params] [, Function callback])

`jtmpl('GET', 'api/endpoint/42') # fire and forget`

`jtmpl('GET', 'api/endpoint/42', function (response) { alert(response) })`

If response is valid JSON, it's automatically parsed

`jtmpl('POST', 'api/endpoint', { id: 42, answer: 42 }, function (err, resp) { ... })`


Main function

Export for NodeJS and browser

A big `if..else if` statement as arguments pattern matcher

    jtmpl = (exports ? this).jtmpl = (target, template, model, options) ->

      args = [].slice.call(arguments)

      # Deprecated. `jtmpl(selector)`?
      if args.length is 1 and typeof args[0] is 'string'
        [].slice.call(document.querySelectorAll(args[0]))

      # `jtmpl(template, model[, options])`?
      else if typeof args[0] is 'string' and typeof args[1] isnt 'string' and args[1] isnt null and args.length in [2, 3]
        template = '' + (args[0].match(RE_NODE_ID) and document.querySelector(args[0]).innerHTML or args[0])
        opts = jtmpl.options(args[2], args[1])

        ## Preprocess template
        for rule in jtmpl.preprocessingRules
          template = template.replace(regexp(rule[0], opts.delimiters), rule[1])

        jtmpl.compile(template, args[1], null, false, opts).trim()

      # `jtmpl(target, model[, options])`?
      else if typeof args[0].cloneNode is 'function' and typeof args[1] is 'object'
        # Pre-binding stage
        jtmpl.prebind(args[1])

        # Bind recursively using data-jt attributes
        jtmpl.bind(args[0], args[1], jtmpl.options(args[2], args[1]))

      # `jtmpl(target, template, model[, options])`
      else
        target = typeof args[0].cloneNode is 'function' and args[0] or document.querySelector(args[0])
        template = args[1].match(RE_NODE_ID) and document.querySelector(args[1]).innerHTML or args[1]
        model = args[2]
        opts = jtmpl.options(args[3], args[2])

        if target.nodeName is 'SCRIPT'
          newTarget = document.createElement(opts.defaultTargetTag)
          newTarget.id = target.id
          target.parentNode.replaceChild(newTarget, target)
          target = newTarget

        html = jtmpl(template, model, opts)
        if target.innerHTML isnt html then target.innerHTML = html

        jtmpl(target, model, opts)



Default options

    jtmpl.defaultOptions = {
      
      delimiters: '{{ }}'

      compiledDelimiters: '#{ }#'

      defaultSection: 'div'

      defaultSectionItem: 'div'

      defaultVar: 'span'

      defaultTargetTag: 'div'
    }

Construct options object by merging default and specified options    

    jtmpl.options = (options, rootModel) ->
      opts = merge(jtmpl.defaultOptions, options or {})
      opts.delimiters = opts.delimiters.split(' ')
      opts.compiledDelimiters = opts.compiledDelimiters.split(' ')
      opts.rootModel ?= rootModel
      opts





## Rules

jtmpl is a processor of rules. 

Rules in sequences are in increasing generality order. It's just like 
[Haskell pattern matching](http://learnyouahaskell.com/syntax-in-functions).

Compilation and binding stages can be extended with new rules,
put them at the beginning:

`jtmpl.compileRules.unshift({ new compile rule... })`  
`jtmpl.bindRules.unshift({ new binding rule... })`





### Regular expression atoms

Used in various matchers

    RE_IDENTIFIER = '[\\w\\.\\-]+'
    RE_NODE_ID = '^#[\\w\\.\\-]+$'
    RE_ANYTHING = '[\\s\\S]*?'
    RE_SPACE = '\\s*'
    RE_DATA_JT = '(?: ( \\s* data-jt = " [^"]* )" )?'
    RE_COLLECTION_TEMPLATE = /^(#|\^)\s([\s\S]*)$/




### Pre-processing rules

Transformations to clean up template for easier matching

    jtmpl.preprocessingRules = [
      # Convert triple mustache (output unescaped var) to alt form
      ["({{) { (#{ RE_IDENTIFIER }) } (}})", '$1&$2$3']

      # Strip HTML comments that enclose tokens
      ["<!-- #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } -->", '$1']

      # Strip single quotes around html element attributes associated with tokens
      ["(#{ RE_IDENTIFIER })='({{ #{ RE_IDENTIFIER } }})'", '$1=$2']

      # Strip double quotes around html element attributes associated with tags
      ["(#{ RE_IDENTIFIER })=\"({{ #{ RE_IDENTIFIER } }})\"", '$1=$2']

      # If tags stand on their own line remove the line, keep the tag only
      ["\\n #{ RE_SPACE } ({{ #{ RE_ANYTHING } }}) #{ RE_SPACE } \\n", '\n$1\n']
    ]




### Compile rules 

Delimiters in `pattern`s are replaced with escaped options.delimiters, whitespace - stripped.

Inline tags implement `replaceWith`, section (block) tags implement `contents`.

Signatures:

[String, Array] `replaceWith` (String for each group in pattern, AnyType model)

String `bindingToken` (String for each group in pattern)

[String, Array] `contents` (String template, AnyType model, String section, Object options)



    jtmpl.compileRules = [




#### `<tag class="{{class-name}} other-classes">`

`model['class-name']` is expected to be boolean

      {
        pattern: "(class=\"? [\\w \\. \\- \\s {{}}]*) {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: (pre, prop, model) ->
          val = model[prop]
          [ # Emit match, and class name if booleanVar
            (pre.search('{') is -1 and pre or ' ') +
            (typeof val is 'boolean' and val and prop or '')
            ,
            []
          ]

        echoReplaceWith: (pre, prop) ->
          if pre.search('{') > - 1 then " {{#{ prop }}}" else null

        bindingToken: (pre, prop) -> "class=#{ prop }"
      }



#### `<tag onevent="{{handler}}">`

`on`-prefixed properties are event handlers.
`handler` is expected to be a function,
`handler`'s `this` is the context in which the handler has been attached.
No need to add `onchange` handlers, syncing of DOM element values and `model` is already handled.

      {
        pattern: "on(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: -> ['', []]

        bindingToken: (event, handler) -> "on#{ event }=#{ handler }"
      }



#### `<tag attr="{{prop}}"`

When `prop` is null property is absent, otherwise equals `prop`.

When `prop` is boolean, value determines presense of attribute.

      {
        pattern: "(#{ RE_IDENTIFIER }) = {{ (#{ RE_IDENTIFIER }) }}$"

        replaceWith: (attr, prop, model) ->
          val = model[prop]
          # null?
          if not val? or val is null
            ['', []]
          # boolean?
          else if typeof val is 'boolean'
            [(if val then attr else ''), []]
          # quoted value
          else
            ["#{ attr }=\"#{ val }\"", []]

        bindingToken: (attr, prop) -> "#{ attr }=#{ prop }"
      }



#### `{{^inverted_section}}`

      {
        pattern: "{{ \\^ (#{ RE_IDENTIFIER }) }}$"

        wrapper: 'defaultSection'

        lastTag: (model, section) ->
          if Array.isArray(model[section]) then section else null

        contents: (template, model, section, options) ->
          val = model[section]

          # Sequence?
          if Array.isArray(val)
            [
              # Render body if array empty
              if not val.length then jtmpl(template, model) else ''
              ,
              [
                [ # template as node data attribute
                  'data-jt-0',

                  multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
                ]
              ]
            ]

          else
            [ jtmpl(template, model),
              if val then [['style', 'display:none']] else []
            ]
        bindingToken: (section) -> "^#{ section }"
      }

      

#### `{{#section}}`

      {
        pattern: "{{ \\# (#{ RE_IDENTIFIER }) }}$"

        lastTag: (model, section) ->
          if Array.isArray(model[section]) then section else null

        wrapper: 'defaultSection'

        contents: (template, model, section, options) ->
          val = model[section]
          # Sequence?
          if Array.isArray(val)
            [ # Render body for each item
              (jtmpl(template, item, { asArrayItem: true }) for item in val).join(''),
              [ # template as node data attribute
                [
                  'data-jt-1',

                  multiReplace(template.trim(), options.delimiters, options.compiledDelimiters)
                ]
              ]
            ]

          # Context?
          else if typeof val is 'object'
            # Render body using context
            [ jtmpl(template, val),
              []
            ]

          else
            [ jtmpl(template, model),
              if not val then [['style', 'display:none']] else []
            ]

        bindingToken: (section) -> "##{ section }"
      }



#### `{{&unescaped_var}}`

      {
        pattern: "{{ & (#{ RE_IDENTIFIER }) }}$"

        wrapper: 'defaultVar'

        replaceWith: (prop, model) -> [prop is '.' and model or model[prop], []]

        bindingToken: (prop) -> prop
      }



#### `{{var}}`

      {
        pattern: "{{ (#{ RE_IDENTIFIER }) }}$"

        wrapper: 'defaultVar'

        replaceWith: (prop, model) -> [escapeHTML(prop is '.' and model or model[prop]), []]

        bindingToken: (prop) -> prop
      }

    ]





### Bind rules

Matching is done on tokenized data-jt items

`react` signature:

Function void (AnyType val) `react`
(DOMElement node, String for each pattern group, AnyType model, Object options)

    jtmpl.bindRules = [




#### `value/checked/selected=var`

      {
        pattern: "(value | checked | selected) = (#{ RE_IDENTIFIER })"

        bindTo: (attr, prop) -> prop,

        react: (node, attr, prop, model) ->
          # attach DOM reactor

          # select option?
          if node.nodeName is 'OPTION'
            node.parentNode.addEventListener('change', ->
              if model[prop] isnt node.selected then model[prop] = node.selected
            )

          # radio group?
          if node.type is 'radio' and node.name
            node.addEventListener('change', ->
              if node[attr]
                for input in document.querySelectorAll("input[type=radio][name=#{ node.name }]")
                  if input isnt node
                    input.dispatchEvent(new Event('change'))
              model[prop] = node[attr]
            )

          # text input?
          if node.type is 'text'
            node.addEventListener('input', -> model[prop] = node[attr])

          # other inputs
          else
            node.addEventListener('change', -> model[prop] = node[attr])

          # return model reactor
          (val) -> if node[attr] isnt val then node[attr] = val
      }



#### onevent=var

      {
        pattern: "on(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })"

        react: (node, evnt, listener, model, options) ->
          handler = options?.rootModel?[listener] or model[listener]
          if typeof handler is 'function'
            node.addEventListener(evnt, handler.bind(model))
          else
            throw ":( #{ listener } is not a function, cannot attach event handler"

          # job done, no reactor to return
          null
      }




#### class=var

      {
        pattern: "class = (#{ RE_IDENTIFIER })"

        bindTo: (prop) -> prop

        react: (node, prop, model) ->
          (val) -> (val and addClass or removeClass)(node, prop)
      }




#### attr=var

      {
        pattern: "(#{ RE_IDENTIFIER }) = (#{ RE_IDENTIFIER })"

        bindTo: (attr, prop) -> prop

        react: (node, attr) ->
          (val) -> if node[attr] isnt val then node[attr] = val
      }




#### section

      {
        pattern: "(# | \\^) (#{ RE_IDENTIFIER })"

        bindTo: (sectionType, prop) -> prop

        # context for recursion
        recurseContext: (sectionType, attr, model) ->
          val = model[attr]
          if Array.isArray(val)
            null
          else if typeof val is 'object'
            val
          else
            model

        react: (node, sectionType, attr, model, options) ->
          val = model[attr]

          if Array.isArray(val) and sectionType is '#'
            jtmpl.bindArrayToNodeChildren(val, node, options)
            # bind collection items to node children
            for child, i in node.children
              if typeof val[i] is 'object'
                jtmpl.bind(child, val[i], options)

          # Return reactor function
          (val) ->
            # collection?
            if Array.isArray(val)
              jtmpl.bindArrayToNodeChildren(val, node, options)

              node.innerHTML =
                if not val.length
                  jtmpl(
                    multiReplace(node.getAttribute('data-jt-0') or '',
                      options.compiledDelimiters, options.delimiters),
                    {}
                  )
                else 
                  ''

              node.appendChild(jtmpl.createSectionItem(node, item, options)) for item in val

            # local context?
            else if typeof val is 'object'
              node.innerHTML = jtmpl(
                multiReplace(node.getAttribute('data-jt-1') or '',
                    options.compiledDelimiters, options.delimiters),
                val
              )
              jtmpl(node, node.innerHTML, val, { rootModel: model })

            # if section
            else
              node.style.display = (!val isnt (sectionType is '^')) and 'none' or ''
      }




#### var

      {
        pattern: "(#{ RE_IDENTIFIER })"

        bindTo: (prop) -> prop

        react: (node, prop, model, options) ->
          (val) -> 
            node.innerHTML = val
            if typeof val is 'object' then jtmpl.bind(node, model, options)
      }

    ]





## Compile rules processor

### Compile routine

Tokenize template and apply each rule on tokens.
Rules can be inline or recursive, end block is hardcoded as "{{/block}}".
Current delimiters are respected.

String  template
AnyType model
String  openTag
Boolean echoMode
Array   delimiters
Boolean asArrayItem


    jtmpl.compile = (template, model, openTag, echoMode, options, asArrayItem) ->

      tokenizer = regexp("{{ (\/?) (#{ RE_ANYTHING }) }}", options.delimiters)
      result = ''
      pos = 0

      while (token = tokenizer.exec(template))

        # End block?
        if token[1]
          if token[2] isnt openTag
            throw new Error(openTag and
              ":( expected {{/#{ openTag }}}, got {{#{ token[2] }}}" or
              ":( unexpected {{/#{ token[2] }}}")
              
          # Exit recursion
          return result + template.slice(pos, tokenizer.lastIndex - token[0].length)

        slice = template.slice(Math.max(0, pos - 128), tokenizer.lastIndex)

        # Process rules
        for rule in jtmpl.compileRules

          match = regexp(rule.pattern, options.delimiters).exec(slice)
          if match
            # accumulate output
            result += template.slice(pos, tokenizer.lastIndex - match[0].length)

            # inject token in data-jt attr
            htagPos = lastOpenedHTMLTag(result)
            bindingToken = rule.bindingToken(match.slice(1)...)

            # inline tag or section?
            if rule.replaceWith?
              if echoMode
                result += rule.echoReplaceWith?(match.slice(1)...) or match[0]
              else
                [replaceWith, wrapperAttrs] =
                  rule.replaceWith(match.slice(1).concat([model])...)

                if htagPos is -1 and rule.wrapper?
                  # wrapping needed
                  tag = options[rule.wrapper]
                  result += injectAttributes(
                    injectTagBinding("<#{ tag }>#{ replaceWith }</#{ tag }>", bindingToken),
                    wrapperAttrs
                  )
                else
                  result += replaceWith
                  result = result.slice(0, htagPos) + injectAttributes(
                    injectTagBinding(result.slice(htagPos), bindingToken),
                    wrapperAttrs
                  )

              pos = tokenizer.lastIndex

            else
              # Recursively get nested template (echoMode=on)
              tmpl = jtmpl.compile(
                template.slice(tokenizer.lastIndex), 
                model, match[1], true, options)

              # Skip block contents
              tokenizer.lastIndex += tmpl.length

              # Match close block token
              closing = tokenizer.exec(template)
              pos = tokenizer.lastIndex

              if echoMode
                result += token[0] + tmpl + closing[0]
              else
                section = match[1]
                [contents, wrapperAttrs] = rule.contents(tmpl, model, section, options)

                if htagPos is -1
                  tag = options[rule.wrapper]

                  if section isnt lastSectionTag
                    lastSectionHTagPos = result.length
                    result += injectAttributes(
                      injectTagBinding("<#{ tag }>#{ contents }</#{ tag }>", bindingToken),
                      wrapperAttrs
                    )
                  else
                    result = (
                      result.slice(0, lastSectionHTagPos) +
                      injectAttributes(
                        injectTagBinding(result.slice(lastSectionHTagPos), bindingToken),
                        wrapperAttrs,
                        contents.trim()
                      )
                    )

                else
                  result = (
                    result.slice(0, htagPos) + 
                    injectAttributes(
                      injectTagBinding(result.slice(htagPos), bindingToken),
                      wrapperAttrs
                    ) +
                    contents.trim()
                  )
                  lastSectionHTagPos = htagPos

                lastSectionTag = rule.lastTag?(model, section) or null


            # Match was found, skip other rules
            break

      result += template.slice(pos)

      # Return accumulated output
      if options.asArrayItem

        # enclose in defaultSectionItem HTML tag if needed
        if isValidHTMLTag(result)
          result 
        else
          tag = options.defaultSectionItem
          "<#{ tag }>#{ result }</#{ tag }>"

      else
        result




### Compiling stage supporting utilities

String addTagBinding(String, String)

Inject token in HTML element data-jt attribute.
Create attribute if not existent.
wrapperAttrs is array of pairs [attribute, value] to inject in element

    injectTagBinding = (template, token) ->
      # group 1: 'data-jt' inject position
      # group 2: token inject position, if attribute exists
      # group 3 (RE_DATA_JT): existing 'data-jt' value
      match = regexp("^ (#{ RE_SPACE } < #{ RE_IDENTIFIER }) (#{ RE_ANYTHING }) #{ RE_DATA_JT }").exec(template)
      attrLen = (match[3] or '').length
      pos = match[1].length + match[2].length + attrLen
      # inject, return result
      ( template.slice(0, pos) +
        ( if attrLen
            (if match[3].trim() is 'data-jt="' then '' else ' ') + token
          else
            ' data-jt="' + token + '"'
        ) +
        template.slice(pos)
      )

    injectAttributes = (template, attributes, contents) ->
      if not attributes.length then return template

      match = regexp("^ (#{ RE_SPACE } < #{ RE_IDENTIFIER } #{ RE_ANYTHING })>").exec(template)
      pos = match[1].length
      (
        template.slice(0, pos) + 
        [" #{ pair[0] }=\"#{ pair[1].replace(/"/g, '&quot;').replace(/>/g, '&gt;').replace(/</g, '&lt;') }\"" for pair in attributes].join('') +
        '>' +
        (contents or '') +
        template.slice(pos + 1)
      )



Int lastOpenedHTMLTag(String)

Return index of the last opening, maybe opened (no close bracket), HTML tag
followed by end of string, or -1, if no such exists

    lastOpenedHTMLTag = (template) ->
      template.trimRight().search(regexp("< #{ RE_IDENTIFIER } [^>]*? >?$"))



Boolean isValidHTMLTag(String)

Check if contents is properly formatted closed HTML tag

    isValidHTMLTag = (contents) ->
      !!contents.trim().match(regexp("^<(#{ RE_IDENTIFIER }) #{ RE_SPACE }
        [^>]*? > #{ RE_ANYTHING } </\\1>$ | < [^>]*? />$")
      )





## Pre-binding stage

Init function (`model['#']`) and routes via window onhashchange are processed here.

If route definition contains a '(', then it's considered regular expression
and groups are passed as parameters to the route handler.

Example routes:

`'#simple-route': function () { ...`

`'#page-(\\d+)': function (pageNumber) { ...`

    jtmpl.prebind = (model) ->
      if typeof model['#'] is 'function'
        model['#'].apply(model)

      props = Object.getOwnPropertyNames(model)
      routes = props.filter((prop) -> regexp("##{ RE_ANYTHING }").exec(prop))

      if routes.length and window
        hashchange = -> 
          for route in routes
            if '(' in route
              match = new RegExp(route, 'g').exec(window.location.hash)
              if match and typeof model[route] is 'function'
                model[route].apply(model, match.slice(1))
            else
              if route is window.location.hash and typeof model[route] is 'function'
                model[route].apply(model)

        hashchange()

        window.addEventListener('hashchange', hashchange)




## Bind rules processor

void `bind` (DOMElement root, AnyType model)

Walk DOM and setup reactors on model and nodes.


    jtmpl.bind = (node, model, options) ->

      if data_jt = node.getAttribute('data-jt')

        for jt in data_jt.trim().split(' ')

          for rule in jtmpl.bindRules

            if match = regexp(rule.pattern).exec(jt)

              reactor = rule.react([node].concat(match.slice(1), [model, options])...)
              prop = rule.bindTo?(match.slice(1)...)
              if model[prop] is undefined then model[prop] = null
              propChange(model, prop, reactor)

              recurseContext = rule.recurseContext?(match.slice(1).concat([model])...)

              break

      if recurseContext isnt null
        for child in node.children
          jtmpl.bind(child, recurseContext or model, options)





## Supporting code


### Useful shortcut

    ap = Array.prototype



### Merge properties into obj copy

    merge = (obj, props) ->
      result = JSON.parse(JSON.stringify(obj))
      for prop of Object.getOwnPropertyNames(props)
        result[prop] = props[prop]
      result


    


### Regular expression utilities

String escapeRE(String s)

Escape regular expression characters

    escapeRE = (s) -> (s + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1')




RegExp regexp(String src, Object options)

Replace mustaches with given delimiters, strip whitespace, return RegExp

    regexp = (src, delimiters) ->
      # strip whitespace
      src = src.replace(/\s+/g, '')
      new RegExp((if delimiters then src
        .replace('{{',  escapeRE(delimiters[0]))
        .replace('}}',  escapeRE(delimiters[1]))
        else src)
      , 'g')




### String utilities

String escapeHTML(String val)

Replace HTML special characters

    escapeHTML = (val) ->
      (val? and val or '')
        .toString()
        .replace /[&"<>\\]/g, (s) -> { 
            '&': '&amp;'
            '\\': '\\\\'
            '"': '\"'
            '<': '&lt;'
            '>': '&gt;'
          }[s]




String multiReplace(String template, Array from, Array to)

Replace `from` literal strings with `to` strings in template

    multiReplace = (template, from, to) ->
      for find, i in from
        template = template.replace(regexp(escapeRE(find)), to[i])
      template






### DOM utilities

DOMElement createSectionItem (DOMElement parent, AnyType context)

    jtmpl.createSectionItem = createSectionItem = (parent, context, options) ->
      if context is undefined then context = {}
      element = document.createElement('body')
      element.innerHTML = jtmpl(
        multiReplace(parent.getAttribute('data-jt-1') or '',
          options.compiledDelimiters, options.delimiters),
        context
      )
      element = element.children[0]
      if typeof context is 'object'
        jtmpl(element, element.innerHTML, context, options)
      element

    jtmpl.hasClass = hasClass = (el, name) -> new RegExp("(\\s|^)#{ name }(\\s|$)").test(el.className)

    jtmpl.addClass = addClass = (el, name) -> 
      if not hasClass(el, name) then el.className += (el.className and ' ' or '') + name

    jtmpl.removeClass = removeClass = (el, name) ->
      if hasClass(el, name) then el.className = el.className
        .replace(new RegExp("(\\s|^)#{name}(\\s|$)"), '')
        .replace(/^\s+|\s+$/g, '')




### Binding utilities

void propChange(Object obj, String prop, Function callback)

Register a callback to handle object property change. 

    propChange = (obj, prop, callback) ->
      # All must be specified, don't fail if not
      if not (obj and prop and callback) then return

      oldDescriptor = (Object.getOwnPropertyDescriptor(obj, prop) or
        Object.getOwnPropertyDescriptor(obj.constructor.prototype, prop))

      Object.defineProperty(obj, prop, {
        get: oldDescriptor.get or -> oldDescriptor.value,
        set: ((val) ->
          oldDescriptor.set?(val) or oldDescriptor.value = val
          callback(val)
        ),
        configurable: true
      })





void bindArrayToNodeChildren(Array array, DOMElement node)

Bind an array to DOM node, 
so when array is modified, node children are updated accordingly.

Array is augmented by attaching listeners on existing indices
and setting a proxy for each mutable operation. 
`createSectionItem` is used for creating new items.


    jtmpl.bindArrayToNodeChildren = bindArrayToNodeChildren = (array, node, options) ->

      # array already augmented?
      if not array.__garbageCollectNodes

        # it's possible for a referenced node to be destroyed. free the reference
        array.__garbageCollectNodes = ->
          i = this.__nodes.length
          while --i
            if not this.__nodes[i].parentNode
              this.__nodes.splice(i, 1)

        array.__removeEmpty = ->
          if not this.length then node.innerHTML = ''

        array.__addEmpty = ->
          if not this.length
            node.innerHTML = jtmpl(
              multiReplace(node.getAttribute('data-jt-0') or '',
                options.compiledDelimiters, options.delimiters),
              {}
            )

        # Mutable array operations

        array.pop = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          node.removeChild(node.children[node.children.length - 1]) for node in this.__nodes
          ap.pop.apply(this, arguments)
          ap.pop.apply(this.__values, arguments)
          this.__addEmpty()

        array.push = (item) ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
          ap.push.apply(this, arguments)
          len = this.__values.length
          result = ap.push.apply(this.__values, arguments)
          bindProp(item, len)
          result

        array.reverse = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          result = ap.reverse.apply(this.__values, arguments)
          for node in this.__nodes
            node.innerHTML = ''
            for item, i in this.__values
              node.appendChild(createSectionItem(node, item, options))
              bindProp(item, i)
          this.__addEmpty()
          result

        array.shift = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          ap.shift.apply(this, arguments)
          result = ap.shift.apply(this.__values, arguments)
          for node in this.__nodes
            node.removeChild(node.children[0])
          for item, i in this.__values
            bindProp(item, i)
          this.__addEmpty()
          result

        array.unshift = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          for item in ap.slice.call(arguments).reverse()
            for node in this.__nodes
              node.insertBefore(createSectionItem(node, item, options), node.children[0])
          ap.unshift.apply(this, arguments)
          result = ap.unshift.apply(this.__values, arguments)
          for item, i in this.__values
            bindProp(item, i)
          this.__addEmpty()
          result

        array.sort = ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          ap.sort.apply(this, arguments)
          result = ap.sort.apply(this.__values, arguments)
          for node in this.__nodes
            node.innerHTML = ''
            for item, i in array
              node.appendChild(createSectionItem(node, item, options)) for node in this.__nodes
              bindProp(item, i)
          this.__addEmpty()
          result

        array.splice = (index, howMany) ->
          this.__removeEmpty()
          this.__garbageCollectNodes()
          for node in this.__nodes
            for i in [0...howMany]
              node.removeChild(node.children[index])
            for item in ap.slice.call(arguments, 2)
              node.insertBefore(createSectionItem(node, item, options), node.children[index])
              bindProp(item, index)
          ap.splice.apply(this, arguments)
          ap.splice.apply(this.__values, arguments)
          this.__addEmpty()

        # Bind property
        bindProp = (item, i) ->
          array.__values[i] = item
          Object.defineProperty(array, i, 
            get: -> this.__values[i]
            set: (val) -> 
              this.__garbageCollectNodes()
              this.__values[i] = val
              node.replaceChild(createSectionItem(node, val, options), node.children[i]) for node in this.__nodes
          )

        # bound nodes
        Object.defineProperty(array, '__nodes',
          enumerable: false
          writable: true
          value: []
        )
        # onchange handlers for each item
        Object.defineProperty(array, '__values',
          enumerable: false
          writable: true
          value: []
        )
        for item, i in array
          bindProp(item, i)

      if array.__nodes.indexOf(node) is -1 then array.__nodes.push(node)
      array
